diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index cb770c3..2edb773 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -270,7 +270,14 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx7d-sdb-sim.dtb \
 	imx7d-sdb-touch.dtb \
 	imx7d-sdb-wm8960.dtb \
-	imx7d-sdb-m4.dtb
+	imx7d-sdb-m4.dtb \
+	imx6sxea-com-kit.dtb \
+	imx6sxea-com-kit-m4.dtb \
+	imx6sxea-com-kit-lvds.dtb \
+	imx6sxea-com-kit-rgb.dtb \
+	imx6qea-com-kit.dtb \
+	imx6ulea-com-kit.dtb \
+	imx7dea-ucom-kit.dtb
 dtb-$(CONFIG_ARCH_MXS) += imx23-evk.dtb \
 	imx23-olinuxino.dtb \
 	imx23-stmp378x_devb.dtb \
diff --git a/arch/arm/boot/dts/imx6qea-com-kit.dts b/arch/arm/boot/dts/imx6qea-com-kit.dts
new file mode 100644
index 0000000..1efc684
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qea-com-kit.dts
@@ -0,0 +1,705 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "imx6qea-com.dtsi"
+
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio3 22 0>;
+			enable-active-high;
+		};
+
+		reg_usb_h1_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_h1>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 0 0>;
+			enable-active-high;
+		};
+
+		/* For uSD/MMC socket on EA COM Base Board */
+		reg_vcc_sd2: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vcc_sd2>;
+			regulator-name = "VCC_SD2";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio7 8 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_lcd_3v3: regulator@3 {
+			compatible = "regulator-fixed";
+			reg = <3>;
+			regulator-name = "lcd-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio6 31 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+			regulator-always-on;
+		};
+
+		reg_vcc_can: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			regulator-name = "VCC_CAN";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+			/*regulator-boot-on;*/
+		};
+
+		reg_lcd_backlight: regulator@5 {
+			compatible = "regulator-fixed";
+			reg = <5>;
+			regulator-name = "lcd-backlight";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio5 0 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+			regulator-always-on;
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&ssi2>;
+		src-port = <2>;
+		ext-port = <3>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB24";
+		mode_str ="EA7-WVGA";
+		default_bpp = <32>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		lcd-supply = <&reg_lcd_3v3>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1>;
+		status = "okay";
+	};
+
+	/* Backlight for LVDS 0 and 1 */
+	backlight_lvds {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	/* Backlight for RGB */
+	backlight_lcd {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		enble-gpios = <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+        gpio-keys {
+                compatible = "gpio-keys";
+                pinctrl-names = "default";
+                pinctrl-0 = <&pinctrl_gpio_keys>;
+
+                power {
+                        label = "Power Button";
+                        gpios = <&gpio3 29 1>;
+                        gpio-key,wakeup;
+                        linux,code = <KEY_POWER>;
+                };
+
+        };
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&i2c1 {
+	
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		AVDD-supply = <&vgen4_reg>;
+		HPVDD-supply = <&vgen4_reg>;
+		DCVDD-supply = <&vgen4_reg>;
+		DBVDD-supply = <&vgen4_reg>;
+	};
+
+	ar1021@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ar1021_int>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <18 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+	};
+
+};
+
+&i2c2 {
+	/* Touch controller for display on LVDS1 connector */
+	egalax_ts@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_egalax_lvds1_int>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <31 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio2 31 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c3 {
+	/* Touch controller for display on LVDS0 connector */
+	egalax_ts@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_egalax_lvds0_int>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		wakeup-gpios = <&gpio3 13 GPIO_ACTIVE_HIGH>;
+	};
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+};
+
+
+&iomuxc {
+	pinctrl-0 = <&pinctrl_hog>, <&pinctrl_can_gpios>, <&pinctrl_lcd_gpios>;
+
+	imx6qea-com-kit {
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
+				MX6QDL_PAD_GPIO_19__CCM_CLKO1		0x130b0
+			>;
+		};
+		
+		pinctrl_ar1021_int: ar1021_intgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A20__GPIO2_IO18          0x1f0b0
+			>;
+		};
+
+		pinctrl_egalax_lvds0_int: egalax_lvds0_intgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_DA13__GPIO3_IO13		0x1f0b0
+			>;
+		};
+
+		pinctrl_egalax_lvds1_int: egalax_lvds1_intgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31		0x1f0b0
+			>;
+		};
+
+		pinctrl_hdmi_cec: hdmicecgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A25__EIM_ADDR25 0x1f8b0
+			>;
+		};
+
+		pinctrl_hdmi_hdcp: hdmihdcpgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_ipu1: ipu1grp {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+			>;
+		};
+
+		pinctrl_ipu1_2: ipu1grp-2 { /* parallel camera */
+			fsl,pins = <
+				MX6QDL_PAD_EIM_A17__IPU2_CSI1_DATA12    0x80000000				
+				MX6QDL_PAD_EIM_A18__IPU2_CSI1_DATA13    0x80000000
+				MX6QDL_PAD_EIM_A19__IPU2_CSI1_DATA14    0x80000000
+				MX6QDL_PAD_EIM_A20__IPU2_CSI1_DATA15    0x80000000
+				MX6QDL_PAD_EIM_A21__IPU2_CSI1_DATA16    0x80000000
+				MX6QDL_PAD_EIM_A22__IPU2_CSI1_DATA17    0x80000000
+				MX6QDL_PAD_EIM_A23__IPU2_CSI1_DATA18    0x80000000
+				MX6QDL_PAD_EIM_A24__IPU2_CSI1_DATA19    0x80000000
+				MX6QDL_PAD_EIM_A16__IPU2_CSI1_PIXCLK   0x80000000
+				MX6QDL_PAD_EIM_DA11__IPU2_CSI1_HSYNC      0x80000000
+				MX6QDL_PAD_EIM_DA12__IPU2_CSI1_VSYNC     0x80000000
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__PWM1_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_pwm2: pwm2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT2__PWM2_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart4: uart4grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09	0x17059
+			>;
+		};
+
+		pinctrl_usb_h1: usbh1grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_0__GPIO1_IO00	0x1b0b0
+			>;
+		};
+
+		pinctrl_vcc_sd2: vccsd2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08			0x17059
+			>;
+		};
+
+		pinctrl_can_gpios: can-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11	0x17059
+			>;
+		}; 
+
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__FLEXCAN1_RX	0x1b020
+				MX6QDL_PAD_KEY_COL2__FLEXCAN1_TX	0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX	0x1b020
+				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX	0x1b020
+			>;
+		};
+
+		pinctrl_lcd_gpios: lcd-gpios {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31		0x17059
+				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00		0x17059
+			>;
+		};
+
+                pinctrl_gpio_keys: gpio_keysgrp {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
+                        >;
+                };
+
+ 	};
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-hdmi";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds1";
+	status = "okay";
+};
+
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <1>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: hsd100pxn1 {
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+
+	lvds-channel@1 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		primary;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&timing1>;
+			timing1: hsd100pxn1 {
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+/* mipi_dsi has the same ip_id/disp_id as the hdmi_core so only enble one of the */
+&mipi_dsi {
+	dev_id = <0>;
+	disp_id = <1>;
+	lcd_panel = "TRULY-WVGA";
+	status = "disabled";
+};
+
+&pcie {
+	reset-gpio = <&gpio1 1 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <4>;
+	vmmc-supply = <&reg_vcc_sd2>;
+	cd-gpios = <&gpio6 9 0>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+
+&wdog1 {
+	status = "okay";
+};
+
+&wdog2 {
+	status = "disabled";
+};
+
+
+&ldb {
+	lvds-channel@0 {
+		crtc = "ipu2-di0";
+	};
+
+	lvds-channel@1 {
+		crtc = "ipu2-di1";
+	};
+};
+
+&mxcfb1 {
+	status = "okay";
+};
+
+&mxcfb2 {
+	status = "okay";
+};
+
+&mxcfb3 {
+	status = "okay";
+};
+
+&mxcfb4 {
+	status = "okay";
+};
+
+&sata {
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_vcc_can>; 
+	trx-en-gpio = <&gpio6 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6qea-com.dtsi b/arch/arm/boot/dts/imx6qea-com.dtsi
new file mode 100644
index 0000000..c7083f6
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qea-com.dtsi
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6q.dtsi"
+
+
+/ {
+	model = "Embedded Artists i.MX6 Quad COM Board";
+	compatible = "fsl,imx6qea-com", "fsl,imx6q";
+
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+
+};
+
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1c_reg>;
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <1>;
+	fsl,wdog-reset = <1>;
+};
+
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rgmii";
+	phy-reset-gpios = <&gpio1 25 0>;
+	fsl,magic-packet;
+	status = "okay";
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 30 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+
+};
+
+
+/* For eMMC socket on EA COM Board */
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+};
+
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6qea-com {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25 0x80000000
+				MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000
+				MX6QDL_PAD_GPIO_9__WDOG1_B 	0x80000000
+			>;
+		};
+
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO	0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI	0x100b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK	0x100b1
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
+			>;
+		};
+
+		pinctrl_enet_irq: enetirqgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30		0x000b1
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
+			 >;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_5__I2C3_SCL		0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x4001b8b1
+			>;
+		};
+
+
+		pinctrl_usdhc4: usdhc4grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD		0x17059
+				MX6QDL_PAD_SD4_CLK__SD4_CLK		0x10059
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0		0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1		0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2		0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3		0x17059
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4		0x17059
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5		0x17059
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6		0x17059
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7		0x17059
+			>;
+		};
+
+
+	};
+};
+
+
+
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts b/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts
new file mode 100644
index 0000000..239e7cd
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-lvds.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+
+
+/*
+ * Disable the RGB interface to only have LVDS enabled
+ */
+&lcdif1 {
+	status = "disabled";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts b/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts
new file mode 100644
index 0000000..875b524
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-m4.dts
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+/{
+	memory {
+		linux,usable-memory = <0x80000000 0x3ff00000>;
+		reg = <0x80000000 0x40000000>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+};
+
+/*
+ * The following modules are conflicting with M4, disable them when m4
+ * is running.
+ */
+&flexcan1 {
+	status = "disabled";
+};
+
+&flexcan2 {
+	status = "disabled";
+};
+
+&i2c3 {
+        status = "disabled";
+};
+
+&mcctest{
+	status = "okay";
+};
+
+&mcctty{
+	status = "okay";
+};
+
+&rpmsg {
+	status = "okay";
+};
+
+&uart2 {
+	status = "disabled";
+};
+
+&adc1 {
+        status = "disabled";
+};
+
+&adc2 {
+        status = "disabled";
+};
+
+&qspi2 {
+	status = "disabled";
+};
+
+&qspi_m4 {
+	status = "okay";
+};
+
+&ocram {
+	reg = <0x00901000 0x1E000>;
+};
+
+&clks {
+	fsl,shared-clks-number = <0x23>;
+	fsl,shared-clks-index = <IMX6SX_CLK_PLL2_BUS IMX6SX_CLK_PLL2_PFD0
+			IMX6SX_CLK_PLL2_PFD2 IMX6SX_CLK_PLL3_USB_OTG
+			IMX6SX_CLK_PLL3_PFD1 IMX6SX_CLK_PLL3_PFD2
+			IMX6SX_CLK_PLL3_PFD3 IMX6SX_CLK_PLL4_AUDIO
+			IMX6SX_CLK_PLL5_VIDEO
+			IMX6SX_CLK_OCRAM IMX6SX_CLK_CAN1_SERIAL
+			IMX6SX_CLK_CAN1_IPG IMX6SX_CLK_CAN2_SERIAL
+			IMX6SX_CLK_CAN2_IPG IMX6SX_CLK_CANFD
+			IMX6SX_CLK_ECSPI1 IMX6SX_CLK_ECSPI2
+			IMX6SX_CLK_ECSPI3 IMX6SX_CLK_ECSPI4
+			IMX6SX_CLK_ECSPI5 IMX6SX_CLK_QSPI1
+			IMX6SX_CLK_QSPI2 IMX6SX_CLK_SSI1
+			IMX6SX_CLK_SSI2 IMX6SX_CLK_SSI3
+			IMX6SX_CLK_UART_SERIAL IMX6SX_CLK_UART_IPG
+			IMX6SX_CLK_PERIPH_CLK2_SEL IMX6SX_CLK_OCRAM_ALT_SEL
+			IMX6SX_CLK_I2C1 IMX6SX_CLK_I2C2
+			IMX6SX_CLK_I2C3 IMX6SX_CLK_I2C4
+			IMX6SX_CLK_EPIT1 IMX6SX_CLK_EPIT2>;
+	fsl,shared-mem-addr = <0x91F000>;
+	fsl,shared-mem-size = <0x1000>;
+};
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts b/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts
new file mode 100644
index 0000000..31312d6
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit-rgb.dts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6sxea-com-kit.dts"
+
+
+
+/*
+ * Disable the LVDS interface to only have RGB enabled
+ */
+&lcdif2 {
+	status = "disabled";
+};
+
+
diff --git a/arch/arm/boot/dts/imx6sxea-com-kit.dts b/arch/arm/boot/dts/imx6sxea-com-kit.dts
new file mode 100644
index 0000000..0b9939e
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com-kit.dts
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6sxea-com.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 SoloX COM Kit";
+	compatible = "fsl,imx6sxea-com", "fsl,imx6sx";
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+
+	backlight1 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		fb-names = "mxs-lcdif0";
+	};
+
+	backlight2 {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		fb-names = "mxs-lcdif1";
+	};
+
+
+	hannstar_cabc {
+		compatible = "hannstar,cabc";
+
+		lvds0 {
+			gpios = <&gpio2 1 GPIO_ACTIVE_HIGH>, <&gpio1 9 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	pxp_v4l2_out {
+		compatible = "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_lcd_3v3: lcd-3v3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lcd-3v3";
+			gpio = <&gpio2 1 1>;
+			enable-active-high;
+			status = "okay";
+		};
+
+		/* For uSD/MMC socket on EA COM Base Board */
+		vcc_sd2: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_vcc_sd2>;
+			regulator-name = "VCC_SD2";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			gpio = <&gpio6 22 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_psu_5v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "PSU-5V0";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-boot-on;
+		};
+
+
+		reg_usb_otg1_vbus: regulator@3 {
+			compatible = "regulator-fixed";
+			reg = <3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_otg1>;
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 18 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+ 
+		reg_usb_otg2_vbus: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_otg2>;
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_pcie: regulator@5 {
+			compatible = "regulator-fixed";
+			reg = <5>;
+			regulator-name = "MPCIE_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&ssi2>;
+		src-port = <2>;
+		ext-port = <6>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+	};
+
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&csi2 {
+	status = "okay";
+	port {
+		csi2_ep: endpoint {
+			remote-endpoint = <&vadc_ep>;
+		};
+	};
+};
+
+
+&lcdif1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	lcd-supply = <&reg_lcd_3v3>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		/* EA 7" display */
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&lcdif2 {
+	display = <&display1>;
+	disp-dev = "ldb";
+	status = "okay";
+
+	display1: display {
+		bits-per-pixel = <16>;
+		bus-width = <18>;
+	};
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <18>;
+		crtc = "lcdif2";
+		status = "okay";
+
+		/* Hannstar 10" */
+		display-timings {
+			native-mode = <&timing1>;
+			timing1: hsd100pxn1 {
+				clock-frequency = <65000000>;
+				hactive = <1024>;
+				vactive = <768>;
+				hback-porch = <220>;
+				hfront-porch = <40>;
+				vback-porch = <21>;
+				vfront-porch = <7>;
+				hsync-len = <60>;
+				vsync-len = <10>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-lcdif1";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds";
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_psu_5v>;
+	trx-en-gpio = <&gpio4 25 GPIO_ACTIVE_LOW>;
+	trx-stby-gpio = <&gpio2 17 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_psu_5v>;
+	trx-en-gpio = <&gpio4 25 GPIO_ACTIVE_LOW>;
+	trx-stby-gpio = <&gpio2 17 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&pcie {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	reset-gpio = <&gpio6 1 0>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&sai1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_sai1>;
+        status = "disabled";
+};
+
+&spdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_spdif>;
+	status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-master";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb_otg1_id>;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	status = "okay";
+};
+
+/* For uSD/MMC socket on EA COM Base Board */
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	cd-gpios = <&gpio2 16 GPIO_ACTIVE_HIGH>;
+	vmmc-supply = <&vcc_sd2>;
+	no-1-8-v;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	status = "okay";
+};
+
+
+&i2c1 {
+	
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6SX_CLK_AUDIO>;
+		AVDD-supply = <&vgen4_reg>;
+		HPVDD-supply = <&vgen4_reg>;
+		DCVDD-supply = <&vgen4_reg>;
+		DBVDD-supply = <&vgen4_reg>;
+	};
+
+	ar1021@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ar1021_int>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+	};
+
+};
+
+&i2c2 {
+
+	egalax_ts@04 {
+		compatible = "eeti,egalax_ts";
+		reg = <0x04>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_egalax_int>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <15 2>;
+		wakeup-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+
+&vadc {
+	vadc_in = <0>;
+	csi_id = <1>;
+	status = "okay";
+	port {
+		vadc_ep: endpoint {
+			remote-endpoint = <&csi2_ep>;
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-0 = <&pinctrl_can_gpios>;
+
+	imx6xea-com-kit {
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6SX_PAD_CSI_DATA00__AUDMUX_AUD6_TXC   0x130b0
+				MX6SX_PAD_CSI_DATA01__AUDMUX_AUD6_TXFS  0x130b0
+				MX6SX_PAD_CSI_HSYNC__AUDMUX_AUD6_TXD    0x120b0
+				MX6SX_PAD_CSI_VSYNC__AUDMUX_AUD6_RXD    0x130b0
+				MX6SX_PAD_CSI_PIXCLK__AUDMUX_MCLK       0x130b0
+			>;
+		};
+
+		pinctrl_canfd1: canfd1grp-1 {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_DQS__CANFD_TX1         0x1b0b0
+				MX6SX_PAD_QSPI1A_SS1_B__CANFD_RX1       0x1b0b0
+			>;
+		};
+
+		pinctrl_canfd2: canfd2grp-1 {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_SS1_B__CANFD_RX2       0x1b0b0
+				MX6SX_PAD_QSPI1A_DQS__CANFD_TX2         0x1b0b0
+			>;
+		};
+
+		pinctrl_ar1021_int: ar1021_intgrp {
+			fsl,pins = <
+				MX6SX_PAD_CSI_DATA03__GPIO1_IO_17       0x1f0b0
+			>;
+		};
+
+
+		pinctrl_egalax_int: egalax_intgrp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_ROW0__GPIO2_IO_15 0x80000000
+			>;
+		};
+
+
+
+		pinctrl_flexcan1: flexcan1grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_DQS__CAN1_TX		0x1b020
+				MX6SX_PAD_QSPI1A_SS1_B__CAN1_RX		0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1B_SS1_B__CAN2_RX		0x1b020
+				MX6SX_PAD_QSPI1A_DQS__CAN2_TX		0x1b020
+			>;
+		};
+
+
+		pinctrl_can_gpios: can-gpios {
+			fsl,pins = <
+				/*MX6SX_PAD_QSPI1B_DATA1__GPIO4_IO_25 0x17059*/
+				MX6SX_PAD_KEY_ROW2__GPIO2_IO_17 0x17059
+			>;
+		};
+
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA18__LCDIF1_DATA_18 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA19__LCDIF1_DATA_19 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA20__LCDIF1_DATA_20 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA21__LCDIF1_DATA_21 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA22__LCDIF1_DATA_22 0x4001b0b0
+				MX6SX_PAD_LCD1_DATA23__LCDIF1_DATA_23 0x4001b0b0
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX6SX_PAD_LCD1_CLK__LCDIF1_CLK	0x4001b0b0
+				MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE 0x4001b0b0
+				MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC 0x4001b0b0
+				MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC 0x4001b0b0
+				MX6SX_PAD_LCD1_RESET__GPIO3_IO_27 0x4001b0b0
+				MX6SX_PAD_GPIO1_IO09__GPIO1_IO_9 0x4001b0b0
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6SX_PAD_USB_H_STROBE__PWM1_OUT 0x110b0
+			>;
+		};
+
+		pinctrl_pwm2: pwm2grp {
+			fsl,pins = <
+				MX6SX_PAD_USB_H_DATA__PWM2_OUT 0x110b0
+			>;
+		};
+
+
+		pinctrl_sai1: sai1grp {
+				fsl,pins = <
+						MX6SX_PAD_CSI_DATA00__SAI1_TX_BCLK     0x130b0
+						MX6SX_PAD_CSI_DATA01__SAI1_TX_SYNC     0x130b0
+						MX6SX_PAD_CSI_HSYNC__SAI1_TX_DATA_0    0x120b0
+						MX6SX_PAD_CSI_VSYNC__SAI1_RX_DATA_0    0x130b0
+						MX6SX_PAD_CSI_PIXCLK__AUDMUX_MCLK      0x130b0
+				>;
+		};
+
+		pinctrl_spdif: spdifgrp {
+			fsl,pins = <
+				MX6SX_PAD_ENET1_RX_CLK__SPDIF_OUT          0x1b0b0
+			>;
+		};
+
+		pinctrl_pcie: pciegrp {
+			fsl,pins = <
+				MX6SX_PAD_SD1_CMD__GPIO6_IO_1 0x10b0
+			>;
+		};
+
+
+		pinctrl_vcc_sd2: vccsd2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD4_RESET_B__GPIO6_IO_22		0x17059
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO04__UART1_TX		0x1f0b1
+				MX6SX_PAD_GPIO1_IO05__UART1_RX		0x1f0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD1_DATA1__UART2_TX		0x1f0b1
+				MX6SX_PAD_SD1_DATA0__UART2_RX		0x1f0b1
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_COL3__UART5_TX		0x1f0b1
+				MX6SX_PAD_KEY_ROW3__UART5_RX		0x1f0b1
+			>;
+		};
+
+		pinctrl_usb_otg1: usbotg1grp {
+			fsl,pins = <
+				MX6SX_PAD_QSPI1A_DATA2__USB_OTG1_PWR	0x10b0
+			>;
+		};
+
+		pinctrl_usb_otg1_id: usbotg1idgrp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID	0x17059
+			>;
+		};
+
+		pinctrl_usb_otg2: usbot2ggrp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12	0x10b0
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6SX_PAD_SD2_CMD__USDHC2_CMD		0x17059
+				MX6SX_PAD_SD2_CLK__USDHC2_CLK		0x10059
+				MX6SX_PAD_SD2_DATA0__USDHC2_DATA0	0x17059
+				MX6SX_PAD_SD2_DATA1__USDHC2_DATA1	0x17059
+				MX6SX_PAD_SD2_DATA2__USDHC2_DATA2	0x17059
+				MX6SX_PAD_SD2_DATA3__USDHC2_DATA3	0x17059
+				MX6SX_PAD_KEY_ROW1__GPIO2_IO_16		0x17059 /* CD */
+			>;
+		};
+
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6sxea-com.dtsi b/arch/arm/boot/dts/imx6sxea-com.dtsi
new file mode 100644
index 0000000..7156e4b
--- /dev/null
+++ b/arch/arm/boot/dts/imx6sxea-com.dtsi
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6sx.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 SoloX COM Board";
+	compatible = "fsl,imx6sxea-com", "fsl,imx6sx";
+
+	memory {
+		reg = <0x80000000 0x40000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+
+		reg_vref_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			regulator-name = "vref-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+	};
+
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_3v3>;
+	status = "okay";
+};
+
+&adc2 {
+	vref-supply = <&reg_vref_3v3>;
+	status = "okay";
+};
+
+
+&cpu0 {
+	operating-points = <
+		/* kHz    uV */
+		996000  1250000
+		792000  1175000
+		396000  1175000
+		198000	1175000
+		>;
+	fsl,soc-operating-points = <
+		/* ARM kHz      SOC uV */
+		996000	1250000
+		792000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+	arm-supply = <&sw1a_reg>;
+	soc-supply = <&sw1a_reg>;
+	fsl,arm-soc-shared = <1>;
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <1>;
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	pinctrl-assert-gpios = <&gpio4 26 GPIO_ACTIVE_HIGH>, <&gpio2 0 GPIO_ACTIVE_LOW>;
+	phy-mode = "rgmii";
+	local-mac-address = [00 1a f1 01 7f 28]; 
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rgmii";
+	local-mac-address = [00 1a f1 01 7f 29]; 
+	status = "okay";
+};
+
+&qspi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi2_1>;
+	status = "okay";
+
+	ddrsmp=<0>;
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+
+	flash1: n25q256a@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <1>;
+	};
+
+};
+
+
+/* For eMMC socket on EA COM Board */
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze200";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+};
+
+
+&vadc {
+	vadc_in = <0>;
+	csi_id = <1>;
+	status = "okay";
+	port {
+		vadc_ep: endpoint {
+			remote-endpoint = <&csi2_ep>;
+		};
+	};
+};
+
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog &pinctrl_can_gpios>;
+
+	imx6xea-com {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/*MX6SX_PAD_SD1_DATA0__GPIO6_IO_2 0x17059
+				MX6SX_PAD_SD1_DATA3__GPIO6_IO_5 0xb000
+				MX6SX_PAD_CSI_DATA03__GPIO1_IO_17 0x17059*/
+				MX6SX_PAD_GPIO1_IO13__WDOG1_WDOG_ANY 0x30b0
+				/*MX6SX_PAD_QSPI1A_SCLK__GPIO4_IO_21  0x17059*/
+			>;
+		};
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX6SX_PAD_ENET1_MDIO__ENET1_MDIO	0xa0b1
+				MX6SX_PAD_ENET1_MDC__ENET1_MDC		0xa0b1
+				MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC	0xa0b9
+				MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0	0xa0b1
+				MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1	0xa0b1
+				MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2	0xa0b1
+				MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3	0xa0b1
+				MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN	0xa0b1
+				MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK	0x3081
+				MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0	0x3081
+				MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1	0x3081
+				MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2	0x3081
+				MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3	0x3081
+				MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN	0x3081
+				MX6SX_PAD_QSPI1A_DATA0__GPIO4_IO_16	0x80000000
+				MX6SX_PAD_ENET1_COL__GPIO2_IO_0 	0x80000000
+				MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M	0x91
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC	0xa0b9
+				MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0	0xa0b1
+				MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1	0xa0b1
+				MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2	0xa0b1
+				MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3	0xa0b1
+				MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN	0xa0b1
+				MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK	0x3081
+				MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0	0x3081
+				MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1	0x3081
+				MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2	0x3081
+				MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3	0x3081
+				MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN	0x3081
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO01__I2C1_SDA 0x4001b8b1
+				MX6SX_PAD_GPIO1_IO00__I2C1_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6SX_PAD_GPIO1_IO03__I2C2_SDA 0x4001b8b1
+				MX6SX_PAD_GPIO1_IO02__I2C2_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6SX_PAD_KEY_ROW4__I2C3_SDA 0x4001b8b1
+				MX6SX_PAD_KEY_COL4__I2C3_SCL 0x4001b8b1
+			>;
+		};
+
+		pinctrl_qspi2_1: qspi2grp_1 {
+			fsl,pins = <
+				MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0     0x70f1
+				MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1  0x70f1
+				MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2    0x70f1
+				MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3    0x70f1
+				MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK        0x70f1
+				MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B       0x70f1
+				MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0   0x70f1
+				MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1   0x70f1
+				MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2     0x70f1
+				MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3     0x70f1
+				MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK     0x70f1
+				/*MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B    0x70f1*/
+			>;
+		};
+
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x17069
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x10071
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x17069
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x17069
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x17069
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x17069
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x17069
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x17069
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x17069
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x17069
+				/*MX6SX_PAD_KEY_COL0__GPIO2_IO_10		0x17059 /* CD * / */
+				/*MX6SX_PAD_KEY_ROW0__GPIO2_IO_15		0x17059 /* WP * / */
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp-100mhz {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x170b9
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x100b9
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x170b9
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x170b9
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x170b9
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x170b9
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x170b9
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x170b9
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x170b9
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x170b9
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp-200mhz {
+			fsl,pins = <
+				MX6SX_PAD_SD3_CMD__USDHC3_CMD		0x170f9
+				MX6SX_PAD_SD3_CLK__USDHC3_CLK		0x100f9
+				MX6SX_PAD_SD3_DATA0__USDHC3_DATA0	0x170f9
+				MX6SX_PAD_SD3_DATA1__USDHC3_DATA1	0x170f9
+				MX6SX_PAD_SD3_DATA2__USDHC3_DATA2	0x170f9
+				MX6SX_PAD_SD3_DATA3__USDHC3_DATA3	0x170f9
+				MX6SX_PAD_SD3_DATA4__USDHC3_DATA4	0x170f9
+				MX6SX_PAD_SD3_DATA5__USDHC3_DATA5	0x170f9
+				MX6SX_PAD_SD3_DATA6__USDHC3_DATA6	0x170f9
+				MX6SX_PAD_SD3_DATA7__USDHC3_DATA7	0x170f9
+			>;
+		};
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ulea-com-kit.dts b/arch/arm/boot/dts/imx6ulea-com-kit.dts
new file mode 100644
index 0000000..d13fce7
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ulea-com-kit.dts
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6ulea-com.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 UltraLite COM Kit";
+	compatible = "fsl,imx6ulea-com", "fsl,imx6ul";
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		status = "okay";
+	};
+
+	pxp_v4l2 {
+		compatible = "fsl,imx6ul-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_can_3v3: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "can-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpios = <&gpio5 1 GPIO_ACTIVE_LOW>;
+		};
+
+		reg_sd1_vmmc: regulator@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "reg-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-wm8731";
+		model = "wm8731-audio";
+		ssi-controller = <&sai2>;
+		src-port = <2>;
+		ext-port = <3>;
+		audio-codec = <&codec>;
+		audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
+		gpr = <&gpr 0x4 20>;
+	};
+
+
+};
+
+
+&clks {
+	assigned-clocks = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <860160000>;
+};
+
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_can_3v3>;
+	trx-en-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can_3v3>;
+	trx-en-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <32>;
+		bus-width = <24>;
+
+		/* EA 7" display */
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+				clock-frequency = <33500000>;
+				hactive = <800>;
+				vactive = <480>;
+				hback-porch = <89>;
+				hfront-porch = <164>;
+				vback-porch = <75>;/*<23>;*/
+				vfront-porch = <75>;/*<10>;*/
+				hsync-len = <10>;
+				vsync-len = <10>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <1>;
+				pixelclk-active = <1>;
+			};
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pxp {
+	status = "okay";
+};
+
+&sai2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+
+	assigned-clocks = <&clks IMX6UL_CLK_SAI2_SEL>,
+			  <&clks IMX6UL_CLK_SAI2>;
+	assigned-clock-parents = <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>;
+	assigned-clock-rates = <0>, <12288000>;
+
+	status = "okay";
+};
+
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_3v3>;
+	status = "okay";
+};
+
+&usbotg2 {
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	cd-gpios = <&gpio1 3 0>;
+	keep-power-in-suspend;
+	enable-sdio-wakeup;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	status = "okay";
+};
+
+
+&i2c1 {
+
+	codec: wm8731@1a {
+		compatible = "wlf,wm8731";
+		reg = <0x1a>;
+		clocks = <&clks IMX6UL_CLK_SAI2>;
+
+		AVDD-supply = <&vgen5_reg>;
+		HPVDD-supply = <&vgen5_reg>;
+		DCVDD-supply = <&vgen5_reg>;
+		DBVDD-supply = <&vgen5_reg>;
+
+	};
+
+	ar1021@4d {
+		compatible = "microchip,ar1021-i2c";
+		reg = <0x4d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ar1021_int>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <24 IRQ_TYPE_EDGE_FALLING>;
+		ar1021,swap_xy;
+		ar1021,invert_x;
+		#ar1021,invert_y;
+	};
+};
+
+
+
+&iomuxc {
+
+	imx6ulea-com-kit {
+
+
+		pinctrl_flexcan1: flexcan1grp{
+			fsl,pins = <
+				MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX	0x1b020
+				MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX	0x1b020
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp{
+			fsl,pins = <
+				MX6UL_PAD_UART2_RTS_B__FLEXCAN2_RX	0x1b020
+				MX6UL_PAD_UART2_CTS_B__FLEXCAN2_TX	0x1b020
+			>;
+		};
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  0x79
+				MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  0x79
+				MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  0x79
+				MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  0x79
+				MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  0x79
+				MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  0x79
+				MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  0x79
+				MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  0x79
+				MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  0x79
+				MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  0x79
+				MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  0x79
+				MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  0x79
+				MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  0x79
+				MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  0x79
+				MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  0x79
+				MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  0x79
+				MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  0x79
+				MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  0x79
+				MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  0x79
+				MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  0x79
+				MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  0x79
+				MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  0x79
+				MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  0x79
+				MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  0x79
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX6UL_PAD_LCD_CLK__LCDIF_CLK	    0x79
+				MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  0x79
+				MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    0x79
+				MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    0x79
+				/* Display power enable */
+				MX6UL_PAD_GPIO1_IO02__GPIO1_IO02    0x79
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO08__PWM1_OUT   0x110b0
+			>;
+		};
+
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1f0b1
+				MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1f0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1f0b1
+				MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1f0b1
+			>;
+		};
+
+		pinctrl_uart3: uart3grp {
+			fsl,pins = <
+				MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1f0b1
+				MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1f0b1
+			>;
+		};
+
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x17059
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x10071
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x17059
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x17059
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x17059
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x17059
+				MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  0x17059
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp100mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x170b9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x100b9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x170b9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x170b9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x170b9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x170b9
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp200mhz {
+			fsl,pins = <
+				MX6UL_PAD_SD1_CMD__USDHC1_CMD     0x170f9
+				MX6UL_PAD_SD1_CLK__USDHC1_CLK     0x100f9
+				MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 0x170f9
+				MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 0x170f9
+				MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 0x170f9
+				MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 0x170f9
+			>;
+		};
+
+
+		pinctrl_sai2: sai2grp {
+			fsl,pins = <
+				MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK	0x17088
+				MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC	0x17088
+				MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA	0x11088
+				MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA	0x11088
+				MX6UL_PAD_JTAG_TMS__SAI2_MCLK		0x17088
+			>;
+		};
+
+		pinctrl_ar1021_int: ar1021_intgrp {
+			fsl,pins = <
+				MX6UL_PAD_CSI_DATA03__GPIO4_IO24       0x1b0b0
+			>;
+		};
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx6ulea-com.dtsi b/arch/arm/boot/dts/imx6ulea-com.dtsi
new file mode 100644
index 0000000..312f485
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ulea-com.dtsi
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <dt-bindings/input/input.h>
+#include "imx6ul.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX6 UltraLite COM Board";
+	compatible = "fsl,imx6ulea-com", "fsl,imx6ul";
+
+	memory {
+		reg = <0x80000000 0x20000000>;
+	};
+
+};
+
+&cpu0 {
+	operating-points = <
+		/* kHz	uV */
+		528000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+	fsl,soc-operating-points = <
+		/* KHz	uV */
+		528000	1175000
+		396000	1175000
+		198000	1175000
+	>;
+
+	arm-supply = <&sw1c_reg>;
+	soc-supply = <&sw1c_reg>;
+	fsl,arm-soc-shared = <1>;
+};
+
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	status = "okay";
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <2>;
+		};
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+		};
+	};
+};
+
+&gpc {
+	fsl,cpu_pupscr_sw2iso = <0x1>;
+	fsl,cpu_pupscr_sw = <0x0>;
+	fsl,cpu_pdnscr_iso2sw = <0x1>;
+	fsl,cpu_pdnscr_iso = <0x1>;
+	fsl,wdog-reset = <1>; /* watchdog select of reset source */
+	fsl,ldo-bypass = <1>; /* use ldo-bypass, u-boot will check it and configure */
+};
+
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pfuze3000@08 {
+		compatible = "fsl,pfuze3000";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1a {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			/* use sw1c_reg to align with pfuze100/pfuze200 */
+			sw1c_reg: sw1b {
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1475000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3 {
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1650000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vldo1 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vldo2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen3_reg: vccsd {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: v33 {
+				regulator-min-microvolt = <2850000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vldo3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vldo4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+	at24@55 {
+		compatible = "at,24c64";
+		pagesize = <32>;
+		reg = <0x55>;
+	};
+
+};
+
+&i2c2 {
+	clock_frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_qspi>;
+	status = "okay";
+	ddrsmp=<0>;
+
+	flash0: n25q256a@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "micron,n25q256a";
+		spi-max-frequency = <29000000>;
+		spi-nor,ddr-quad-read-dummy = <6>;
+		reg = <0>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+	imx6ulea-com {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX6UL_PAD_LCD_RESET__WDOG1_WDOG_ANY    0x30b0
+				MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	0x17059 /* SD1 VSELECT */
+				MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 /* SD1 RESET */
+				MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01      0x17059 /* CAN Regulator */
+			>;
+		};
+
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b031
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX6UL_PAD_GPIO1_IO07__ENET2_MDC		0x1b0b0
+				MX6UL_PAD_GPIO1_IO06__ENET2_MDIO	0x1b0b0
+				MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
+				MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b0b0
+				MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b0b0
+				MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b031
+				MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00	0x80000000
+			>;
+		};
+
+
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x10069
+				MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x17059
+				MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059
+				MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059
+				MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059
+				MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
+			>;
+		};
+
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0
+				MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6UL_PAD_UART5_TX_DATA__I2C2_SCL 0x4001b8b0
+				MX6UL_PAD_UART5_RX_DATA__I2C2_SDA 0x4001b8b0
+			>;
+		};
+
+		pinctrl_qspi: qspigrp {
+			fsl,pins = <
+				MX6UL_PAD_NAND_WP_B__QSPI_A_SCLK      0x70a1
+				MX6UL_PAD_NAND_READY_B__QSPI_A_DATA00 0x70a1
+				MX6UL_PAD_NAND_CE0_B__QSPI_A_DATA01   0x70a1
+				MX6UL_PAD_NAND_CE1_B__QSPI_A_DATA02   0x70a1
+				MX6UL_PAD_NAND_CLE__QSPI_A_DATA03     0x70a1
+				MX6UL_PAD_NAND_DQS__QSPI_A_SS0_B      0x70a1
+			>;
+		};
+
+
+
+	};
+};
diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit.dts b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
new file mode 100644
index 0000000..8448923
--- /dev/null
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
@@ -0,0 +1,1290 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include "imx7d.dtsi"
+
+/ {
+	model = "Embedded Artists i.MX7 Dual uCOM Kit";
+	compatible = "fsl,imx7dea-ucom", "fsl,imx7d";
+
+	memory {
+		reg = <0x80000000 0x80000000>;
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <6>;
+		status = "okay";
+	};
+
+	pxp_v4l2_out {
+		compatible = "fsl,imx7d-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+		status = "okay";
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg1_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio1 5 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_usb_otg2_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "usb_otg2_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 7 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+
+		reg_can2_3v3: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "can2-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2 14 GPIO_ACTIVE_LOW>;
+		};
+
+		reg_vref_1v8: regulator@3 {
+			compatible = "regulator-fixed";
+			regulator-name = "vref-1v8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+		};
+
+		reg_pcie: regulator@4 {
+			compatible = "regulator-fixed";
+			reg = <4>;
+			regulator-name = "MPCIE_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio_spi 6 GPIO_ACTIVE_HIGH>;
+			regulator-always-on;
+			enable-active-high;
+		};
+
+		reg_sd1_vmmc: regulator@5 {
+			compatible = "regulator-fixed";
+			regulator-name = "VDD_SD1";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio5 2 GPIO_ACTIVE_HIGH>;
+			startup-delay-us = <200000>;
+			enable-active-high;
+		};
+
+		wlreg_on: fixedregulator@100 {
+			compatible = "regulator-fixed";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-name = "wlreg_on";
+			gpio = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+			enable-active-high;
+		};
+	};
+
+	bcmdhd_wlan_0: bcmdhd_wlan@0 {
+		compatible = "android,bcmdhd_wlan";
+		wlreg_on-supply = <&wlreg_on>;
+	};
+
+	sound {
+		compatible = "fsl,imx7d-evk-wm8960",
+			   "fsl,imx-audio-wm8960";
+		model = "wm8960-audio";
+		cpu-dai = <&sai1>;
+		audio-codec = <&codec>;
+		codec-master;
+		/* JD2: hp detect high for headphone*/
+		hp-det = <2 0>;
+		audio-routing =
+			"LINPUT1", "Main MIC",
+			"Main MIC", "MICB";
+		assigned-clocks = <&clks IMX7D_AUDIO_MCLK_ROOT_SRC>,
+				  <&clks IMX7D_AUDIO_MCLK_ROOT_CLK>;
+		assigned-clock-parents = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
+		assigned-clock-rates = <0>, <12288000>;
+
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx7d-sdb-sii902x",
+			   "fsl,imx-audio-sii902x";
+		model = "sii902x-audio";
+		cpu-dai = <&sai1>;
+		hdmi-controler = <&sii902x>;
+	};
+
+	spi4 {
+		compatible = "spi-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_spi1>;
+		status = "okay";
+		gpio-sck = <&gpio1 13 0>;
+		gpio-mosi = <&gpio1 9 0>;
+		cs-gpios = <&gpio1 12 0>;
+		num-chipselects = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		gpio_spi: gpio_spi@0 {
+			compatible = "fairchild,74hc595";
+			gpio-controller;
+			#gpio-cells = <2>;
+			reg = <0>;
+			registers-number = <1>;
+			registers-default = /bits/ 8 <0x54>; /* Enable PERI_3V3, SENSOR_RST_B and HDMI_RST*/
+			spi-max-frequency = <100000>;
+		};
+	};
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&adc2 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&clks {
+	assigned-clocks = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
+	assigned-clock-rates = <884736000>;
+};
+
+&cpu0 {
+	arm-supply = <&sw1a_reg>;
+};
+
+&csi1 {
+	csi-mux-mipi = <&gpr 0x14 4>;
+	status = "okay";
+
+	port {
+		csi_ep: endpoint {
+			remote-endpoint = <&csi_mipi_ep>;
+		};
+	};
+};
+
+&epdc {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_epdc0>;
+        V3P3-supply = <&V3P3_reg>;
+        VCOM-supply = <&VCOM_reg>;
+        DISPLAY-supply = <&DISPLAY_reg>;
+	en-gpios = <&gpio_spi 5 0>;
+        status = "disabled";
+};
+
+&epxp {
+	status = "okay";
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	pinctrl-assert-gpios = <&gpio_spi 5 GPIO_ACTIVE_HIGH>;
+	assigned-clocks = <&clks IMX7D_ENET1_TIME_ROOT_SRC>,
+			  <&clks IMX7D_ENET1_TIME_ROOT_CLK>;
+	assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_100M_CLK>;
+	assigned-clock-rates = <0>, <100000000>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+		};
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+		};
+	};
+};
+
+&fec2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet2>;
+	assigned-clocks = <&clks IMX7D_ENET2_TIME_ROOT_SRC>,
+			  <&clks IMX7D_ENET2_TIME_ROOT_CLK>;
+	assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_100M_CLK>;
+	assigned-clock-rates = <0>, <100000000>;
+	phy-mode = "rgmii";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "disabled";
+};
+
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can2_3v3>;
+	status = "okay";
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_1>;
+	status = "disabled";
+	nand-on-flash-bbt;
+};
+
+&mipi_csi {
+	clock-frequency = <240000000>;
+	status = "okay";
+	port {
+		mipi_sensor_ep: endpoint1 {
+			remote-endpoint = <&ov5647_mipi_ep>;
+			data-lanes = <2>;
+			csis-hs-settle = <13>;
+			csis-wclk;
+		};
+
+		csi_mipi_ep: endpoint2 {
+			remote-endpoint = <&csi_ep>;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: bd7181x@4b {
+		reg = <0x4b>;
+		compatible = "rohm,bd71815";
+		/* PMIC_INT_B GPIO1_IO12 */
+		gpio_intr = <&gpio1 12 0>;
+
+		gpo {
+			rohm,mode = <0x30>;	/* 0b0011_0000 all gpos with cmos output mode */
+		};
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			buck3_reg: regulator@2 {
+				reg = <2>;
+				regulator-compatible = "buck3";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <2700000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1850000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			dvref_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "dvref";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			lpsr_reg: regulator@11 {
+				reg = <11>;
+				regulator-compatible = "lpsr";
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			wled_reg: regulator@12 {
+				reg = <12>;
+				regulator-compatible = "wled";
+				regulator-min-microamp = <10>;
+				regulator-max-microamp = <25000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+				regulator-always-on;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+		regulator-virtuals {
+			compatible = "simple-bus";
+
+			virt-buck1 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck1";
+			};
+			virt-buck2 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck2";
+			};
+			virt-buck3 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck3";
+			};
+			virt-buck4 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck4";
+			};
+			virt-buck5 {
+				compatible = "regulator-virtual";
+				virtual-supply = "buck5";
+			};
+			virt-ldo1 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo1";
+			};
+			virt-ldo2 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo2";
+			};
+			virt-ldo3 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo3";
+			};
+			virt-ldo4 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo4";
+			};
+			virt-ldo5 {
+				compatible = "regulator-virtual";
+				virtual-supply = "ldo5";
+			};
+			user-dvref {
+				compatible = "userspace_consumer";
+				uc-name = "dvref";
+				suck-supply = "dvref";
+			};
+			user-lpsr {
+				compatible = "userspace_consumer";
+				uc-name = "lpsr";
+				suck-supply = "lpsr";
+			};
+
+			virt-wled {
+				compatible = "regulator-virtual";
+				virtual-supply = "wled";
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	fxas2100x@20 {
+		compatible = "fsl,fxas2100x";
+		reg = <0x20>;
+	};
+
+	fxos8700@1e {
+		compatible = "fsl,fxos8700";
+		reg = <0x1e>;
+	};
+
+	mpl3115@60 {
+		compatible = "fsl,mpl3115";
+		reg = <0x60>;
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	max17135: max17135@48 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_max17135>;
+		compatible = "maxim,max17135";
+		reg = <0x48>;
+		status = "disabled";
+
+		vneg_pwrup = <1>;
+		gvee_pwrup = <2>;
+		vpos_pwrup = <10>;
+		gvdd_pwrup = <12>;
+		gvdd_pwrdn = <1>;
+		vpos_pwrdn = <2>;
+		gvee_pwrdn = <8>;
+		vneg_pwrdn = <10>;
+		gpio_pmic_pwrgood = <&gpio2 31 0>;
+		gpio_pmic_vcom_ctrl = <&gpio4 14 0>;
+		gpio_pmic_wakeup = <&gpio2 23 0>;
+		gpio_pmic_v3p3 = <&gpio2 30 0>;
+		gpio_pmic_intr = <&gpio2 22 0>;
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			GVDD_reg: GVDD {
+				/* 20v */
+				regulator-name = "GVDD";
+			};
+
+			GVEE_reg: GVEE {
+				/* -22v */
+				regulator-name = "GVEE";
+			};
+
+			HVINN_reg: HVINN {
+				/* -22v */
+				regulator-name = "HVINN";
+			};
+
+			HVINP_reg: HVINP {
+				/* 20v */
+				regulator-name = "HVINP";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			VNEG_reg: VNEG {
+				/* -15v */
+				regulator-name = "VNEG";
+			};
+
+			VPOS_reg: VPOS {
+				/* 15v */
+				regulator-name = "VPOS";
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		};
+	};
+
+	sii902x: sii902x@39 {
+		compatible = "SiI,sii902x";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sii902x>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		mode_str ="1280x720M@60";
+		bits-per-pixel = <16>;
+		reg = <0x39>;
+		status = "okay";
+	};
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+
+	codec: wm8960@1a {
+		compatible = "wlf,wm8960";
+		reg = <0x1a>;
+		clocks = <&clks IMX7D_AUDIO_MCLK_ROOT_CLK>;
+		clock-names = "mclk";
+		wlf,shared-lrclk;
+	};
+
+	ov5647_mipi: ov5647_mipi@36 {
+		compatible = "ovti,ov5647_mipi";
+		reg = <0x36>;
+		clocks = <&clks IMX7D_CLK_DUMMY>;
+		clock-names = "csi_mclk";
+		csi_id = <0>;
+		pwn-gpios = <&gpio_spi 7 GPIO_ACTIVE_HIGH>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		port {
+			ov5647_mipi_ep: endpoint {
+				remote-endpoint = <&mipi_sensor_ep>;
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_1>;
+
+	imx7d-sdb {
+		pinctrl_hog_1: hoggrp-1 {
+			fsl,pins = <
+				MX7D_PAD_UART3_CTS_B__GPIO4_IO7	0x14
+				MX7D_PAD_ECSPI2_SS0__GPIO4_IO23	 0x80000000  /* bt reg on */
+				MX7D_PAD_GPIO1_IO08__SD1_VSELECT	0x59 /* VSELECT */
+				MX7D_PAD_SD1_CD_B__GPIO5_IO0		0x59 /* CD */
+				MX7D_PAD_SD1_WP__GPIO5_IO1		0x59 /* WP */
+				MX7D_PAD_SD1_RESET_B__GPIO5_IO2		0x59 /* vmmc */
+			>;
+		};
+
+                pinctrl_epdc0: epdcgrp0 {
+                        fsl,pins = <
+				MX7D_PAD_EPDC_DATA00__EPDC_DATA0  0x2
+				MX7D_PAD_EPDC_DATA01__EPDC_DATA1  0x2
+				MX7D_PAD_EPDC_DATA02__EPDC_DATA2  0x2
+				MX7D_PAD_EPDC_DATA03__EPDC_DATA3  0x2
+				MX7D_PAD_EPDC_DATA04__EPDC_DATA4  0x2
+				MX7D_PAD_EPDC_DATA05__EPDC_DATA5  0x2
+				MX7D_PAD_EPDC_DATA06__EPDC_DATA6  0x2
+				MX7D_PAD_EPDC_DATA07__EPDC_DATA7  0x2
+				MX7D_PAD_EPDC_DATA08__EPDC_DATA8  0x2
+				MX7D_PAD_EPDC_DATA09__EPDC_DATA9  0x2
+				MX7D_PAD_EPDC_DATA10__EPDC_DATA10 0x2
+				MX7D_PAD_EPDC_DATA11__EPDC_DATA11 0x2
+				MX7D_PAD_EPDC_DATA12__EPDC_DATA12 0x2
+				MX7D_PAD_EPDC_DATA13__EPDC_DATA13 0x2
+				MX7D_PAD_EPDC_DATA14__EPDC_DATA14 0x2
+				MX7D_PAD_EPDC_DATA15__EPDC_DATA15 0x2
+				MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK   0x2
+				MX7D_PAD_EPDC_SDLE__EPDC_SDLE     0x2
+				MX7D_PAD_EPDC_SDOE__EPDC_SDOE     0x2
+				MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR   0x2
+				MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0   0x2
+				MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1   0x2
+				MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK   0x2
+				MX7D_PAD_EPDC_GDOE__EPDC_GDOE     0x2
+				MX7D_PAD_EPDC_GDRL__EPDC_GDRL     0x2
+				MX7D_PAD_EPDC_GDSP__EPDC_GDSP     0x2
+				MX7D_PAD_EPDC_BDR0__EPDC_BDR0     0x2
+				MX7D_PAD_EPDC_BDR1__EPDC_BDR1     0x2
+                        >;
+                };
+
+		pinctrl_enet1: enet1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO10__ENET1_MDIO		0x3
+				MX7D_PAD_GPIO1_IO11__ENET1_MDC		0x3
+				MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC	0x1
+				MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0	0x1
+				MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1	0x1
+				MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2	0x1
+				MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3	0x1
+				MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL	0x1
+				MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC	0x1
+				MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0	0x1
+				MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1	0x1
+				MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2	0x1
+				MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3	0x1
+				MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL	0x1
+			>;
+		};
+
+		pinctrl_enet2: enet2grp {
+			fsl,pins = <
+				MX7D_PAD_EPDC_GDSP__ENET2_RGMII_TXC		0x1
+				MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0		0x1
+				MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1		0x1
+				MX7D_PAD_EPDC_GDCLK__ENET2_RGMII_TD2		0x1
+				MX7D_PAD_EPDC_GDOE__ENET2_RGMII_TD3		0x1
+				MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL		0x1
+				MX7D_PAD_EPDC_SDCE1__ENET2_RGMII_RXC		0x1
+				MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0		0x1
+				MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1		0x1
+				MX7D_PAD_EPDC_SDOE__ENET2_RGMII_RD2		0x1
+				MX7D_PAD_EPDC_SDSHR__ENET2_RGMII_RD3		0x1
+				MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL		0x1
+			>;
+		};
+
+		pinctrl_ecspi3_cs: ecspi3_cs_grp {
+			fsl,pins = <
+				MX7D_PAD_SD2_CD_B__GPIO5_IO9	0x80000000
+			>;
+		};
+
+		pinctrl_ecspi3: ecspi3grp {
+			fsl,pins = <
+				MX7D_PAD_SAI2_TX_SYNC__ECSPI3_MISO	0x2
+				MX7D_PAD_SAI2_TX_BCLK__ECSPI3_MOSI	0x2
+				MX7D_PAD_SAI2_RX_DATA__ECSPI3_SCLK	0x2
+			>;
+		};
+
+		pinctrl_tsc2046_pendown: tsc2046_pendown {
+			fsl,pins = <
+				MX7D_PAD_EPDC_DATA13__GPIO2_IO13 0x59
+			>;
+		};
+
+		pinctrl_flexcan2: flexcan2grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO14__FLEXCAN2_RX	0x59
+				MX7D_PAD_GPIO1_IO15__FLEXCAN2_TX	0x59
+			>;
+		};
+
+		pinctrl_gpmi_nand_1: gpmi-nand-1 {
+			fsl,pins = <
+				MX7D_PAD_SD3_CLK__NAND_CLE			0x71
+				MX7D_PAD_SD3_CMD__NAND_ALE			0x71
+				MX7D_PAD_SAI1_MCLK__NAND_WP_B		0x71
+				MX7D_PAD_SAI1_TX_BCLK__NAND_CE0_B	0x71
+				MX7D_PAD_SAI1_RX_DATA__NAND_CE1_B	0x71
+				MX7D_PAD_SAI1_TX_DATA__NAND_READY_B	0x74
+				MX7D_PAD_SD3_STROBE__NAND_RE_B		0x71
+				MX7D_PAD_SD3_RESET_B__NAND_WE_B		0x71
+				MX7D_PAD_SD3_DATA0__NAND_DATA00		0x71
+				MX7D_PAD_SD3_DATA1__NAND_DATA01		0x71
+				MX7D_PAD_SD3_DATA2__NAND_DATA02		0x71
+				MX7D_PAD_SD3_DATA3__NAND_DATA03		0x71
+				MX7D_PAD_SD3_DATA4__NAND_DATA04		0x71
+				MX7D_PAD_SD3_DATA5__NAND_DATA05		0x71
+				MX7D_PAD_SD3_DATA6__NAND_DATA06		0x71
+				MX7D_PAD_SD3_DATA7__NAND_DATA07		0x71
+
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX7D_PAD_I2C1_SDA__I2C1_SDA	0x4000007f
+				MX7D_PAD_I2C1_SCL__I2C1_SCL	0x4000007f
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX7D_PAD_I2C2_SDA__I2C2_SDA	0x4000007f
+				MX7D_PAD_I2C2_SCL__I2C2_SCL	0x4000007f
+			>;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX7D_PAD_I2C3_SDA__I2C3_SDA          0x4000007f
+				MX7D_PAD_I2C3_SCL__I2C3_SCL          0x4000007f
+			>;
+		};
+
+		pinctrl_i2c4: i2c4grp {
+			fsl,pins = <
+				MX7D_PAD_SAI1_RX_BCLK__I2C4_SDA		0x4000007f
+				MX7D_PAD_SAI1_RX_SYNC__I2C4_SCL		0x4000007f
+			>;
+		};
+
+		pinctrl_lcdif_dat: lcdifdatgrp {
+			fsl,pins = <
+				MX7D_PAD_LCD_DATA00__LCD_DATA0	0x79
+				MX7D_PAD_LCD_DATA01__LCD_DATA1	0x79
+				MX7D_PAD_LCD_DATA02__LCD_DATA2	0x79
+				MX7D_PAD_LCD_DATA03__LCD_DATA3	0x79
+				MX7D_PAD_LCD_DATA04__LCD_DATA4	0x79
+				MX7D_PAD_LCD_DATA05__LCD_DATA5	0x79
+				MX7D_PAD_LCD_DATA06__LCD_DATA6	0x79
+				MX7D_PAD_LCD_DATA07__LCD_DATA7	0x79
+				MX7D_PAD_LCD_DATA08__LCD_DATA8	0x79
+				MX7D_PAD_LCD_DATA09__LCD_DATA9	0x79
+				MX7D_PAD_LCD_DATA10__LCD_DATA10	0x79
+				MX7D_PAD_LCD_DATA11__LCD_DATA11	0x79
+				MX7D_PAD_LCD_DATA12__LCD_DATA12	0x79
+				MX7D_PAD_LCD_DATA13__LCD_DATA13	0x79
+				MX7D_PAD_LCD_DATA14__LCD_DATA14	0x79
+				MX7D_PAD_LCD_DATA15__LCD_DATA15	0x79
+				MX7D_PAD_LCD_DATA16__LCD_DATA16	0x79
+				MX7D_PAD_LCD_DATA17__LCD_DATA17	0x79
+				MX7D_PAD_LCD_DATA18__LCD_DATA18	0x79
+				MX7D_PAD_LCD_DATA19__LCD_DATA19	0x79
+				MX7D_PAD_LCD_DATA20__LCD_DATA20	0x79
+				MX7D_PAD_LCD_DATA21__LCD_DATA21	0x79
+				MX7D_PAD_LCD_DATA22__LCD_DATA22	0x79
+				MX7D_PAD_LCD_DATA23__LCD_DATA23	0x79
+			>;
+		};
+
+		pinctrl_lcdif_ctrl: lcdifctrlgrp {
+			fsl,pins = <
+				MX7D_PAD_LCD_CLK__LCD_CLK	0x79
+				MX7D_PAD_LCD_ENABLE__LCD_ENABLE	0x79
+				MX7D_PAD_LCD_VSYNC__LCD_VSYNC	0x79
+				MX7D_PAD_LCD_HSYNC__LCD_HSYNC	0x79
+				MX7D_PAD_LCD_RESET__LCD_RESET	0x79
+			>;
+		};
+
+		pinctrl_max17135: max17135grp-1 {
+			fsl,pins = <
+				MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31	0x80000000  /* pwrgood */
+				MX7D_PAD_I2C4_SCL__GPIO4_IO14		0x80000000  /* vcom_ctrl */
+				MX7D_PAD_EPDC_SDCE3__GPIO2_IO23		0x80000000  /* wakeup */
+				MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30	0x80000000  /* v3p3 */
+				MX7D_PAD_EPDC_SDCE2__GPIO2_IO22		0x80000000  /* pwr int */
+			>;
+		};
+
+		pinctrl_sii902x: hdmigrp-1 {
+			fsl,pins = <
+				MX7D_PAD_EPDC_DATA13__GPIO2_IO13 0x59
+			>;
+		};
+
+		pinctrl_sim1_1: sim1grp-1 {
+			fsl,pins = <
+				MX7D_PAD_EPDC_DATA10__SIM1_PORT1_RST_B		0x77
+				MX7D_PAD_EPDC_DATA12__SIM1_PORT1_PD		0x77
+				MX7D_PAD_EPDC_DATA11__SIM1_PORT1_SVEN		0x77
+				MX7D_PAD_EPDC_DATA09__SIM1_PORT1_CLK		0x73
+				MX7D_PAD_EPDC_DATA08__SIM1_PORT1_TRXD		0x73
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX 0x79
+				MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX 0x79
+			>;
+		};
+
+		pinctrl_uart5: uart5grp {
+			fsl,pins = <
+				MX7D_PAD_SAI1_TX_BCLK__UART5_DCE_TX 0x79
+				MX7D_PAD_SAI1_RX_DATA__UART5_DCE_RX 0x79
+				MX7D_PAD_SAI1_TX_SYNC__UART5_DCE_CTS 0x79
+				MX7D_PAD_SAI1_TX_DATA__UART5_DCE_RTS 0x79
+			>;
+		};
+
+		pinctrl_uart5dte: uart5dtegrp {
+			fsl,pins = <
+				MX7D_PAD_SAI1_TX_BCLK__UART5_DTE_RX 0x79
+				MX7D_PAD_SAI1_RX_DATA__UART5_DTE_TX 0x79
+				MX7D_PAD_SAI1_TX_SYNC__UART5_DTE_RTS 0x79
+				MX7D_PAD_SAI1_TX_DATA__UART5_DTE_CTS 0x79
+			>;
+		};
+
+		pinctrl_uart6: uart6grp {
+			fsl,pins = <
+				MX7D_PAD_ECSPI1_MOSI__UART6_DCE_TX 0x79
+				MX7D_PAD_ECSPI1_SCLK__UART6_DCE_RX 0x79
+				MX7D_PAD_ECSPI1_SS0__UART6_DCE_CTS 0x79
+				MX7D_PAD_ECSPI1_MISO__UART6_DCE_RTS 0x79
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x59
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x19
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x59
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x59
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x59
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x59
+			>;
+		};
+
+		pinctrl_usdhc1_100mhz: usdhc1grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x5a
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x1a
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x5a
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x5a
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x5a
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x5a
+			>;
+		};
+
+		pinctrl_usdhc1_200mhz: usdhc1grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD1_CMD__SD1_CMD	0x5b
+				MX7D_PAD_SD1_CLK__SD1_CLK	0x1b
+				MX7D_PAD_SD1_DATA0__SD1_DATA0	0x5b
+				MX7D_PAD_SD1_DATA1__SD1_DATA1	0x5b
+				MX7D_PAD_SD1_DATA2__SD1_DATA2	0x5b
+				MX7D_PAD_SD1_DATA3__SD1_DATA3	0x5b
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x59
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x19
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x59
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x59
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x59
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x59
+				MX7D_PAD_ECSPI2_MOSI__GPIO4_IO21	0x59 /* WL_REG_ON */
+			>;
+		};
+
+		pinctrl_usdhc2_100mhz: usdhc2grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x5a
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x1a
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x5a
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5a
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5a
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5a
+			>;
+		};
+
+		pinctrl_usdhc2_200mhz: usdhc2grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD2_CMD__SD2_CMD       0x5b
+				MX7D_PAD_SD2_CLK__SD2_CLK       0x1b
+				MX7D_PAD_SD2_DATA0__SD2_DATA0   0x5b
+				MX7D_PAD_SD2_DATA1__SD2_DATA1   0x5b
+				MX7D_PAD_SD2_DATA2__SD2_DATA2   0x5b
+				MX7D_PAD_SD2_DATA3__SD2_DATA3   0x5b
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x59
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x19
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x59
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x59
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x59
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x59
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x59
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x59
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x59
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x59
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x19
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp_100mhz {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x5a
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x1a
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x5a
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x5a
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x5a
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x5a
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x5a
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x5a
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x5a
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x5a
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x1a
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp_200mhz {
+			fsl,pins = <
+				MX7D_PAD_SD3_CMD__SD3_CMD	0x5b
+				MX7D_PAD_SD3_CLK__SD3_CLK	0x1b
+				MX7D_PAD_SD3_DATA0__SD3_DATA0	0x5b
+				MX7D_PAD_SD3_DATA1__SD3_DATA1	0x5b
+				MX7D_PAD_SD3_DATA2__SD3_DATA2	0x5b
+				MX7D_PAD_SD3_DATA3__SD3_DATA3	0x5b
+				MX7D_PAD_SD3_DATA4__SD3_DATA4	0x5b
+				MX7D_PAD_SD3_DATA5__SD3_DATA5	0x5b
+				MX7D_PAD_SD3_DATA6__SD3_DATA6	0x5b
+				MX7D_PAD_SD3_DATA7__SD3_DATA7	0x5b
+				MX7D_PAD_SD3_STROBE__SD3_STROBE	0x1b
+				MX7D_PAD_SD3_RESET_B__SD3_RESET 0x59
+			>;
+		};
+
+		pinctrl_sai1: sai1grp {
+			fsl,pins = <
+				MX7D_PAD_SAI1_MCLK__SAI1_MCLK           0x1f
+				MX7D_PAD_ENET1_RX_CLK__SAI1_TX_BCLK     0x1f
+				MX7D_PAD_ENET1_CRS__SAI1_TX_SYNC	0x1f
+				MX7D_PAD_ENET1_COL__SAI1_TX_DATA0	0x30
+				MX7D_PAD_ENET1_TX_CLK__SAI1_RX_DATA0	0x1f
+			>;
+		};
+
+		pinctrl_sai2: sai2grp {
+			fsl,pins = <
+				MX7D_PAD_SAI2_TX_BCLK__SAI2_TX_BCLK     0x1f
+				MX7D_PAD_SAI2_TX_SYNC__SAI2_TX_SYNC     0x1f
+				MX7D_PAD_SAI2_TX_DATA__SAI2_TX_DATA0    0x30
+				MX7D_PAD_SAI2_RX_DATA__SAI2_RX_DATA0    0x1f
+			>;
+		};
+
+		pinctrl_spi1: spi1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO09__GPIO1_IO9	0x59
+				MX7D_PAD_GPIO1_IO12__GPIO1_IO12	0x59
+				MX7D_PAD_GPIO1_IO13__GPIO1_IO13	0x59
+			>;
+		};
+	};
+};
+
+&iomuxc_lpsr {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_2>;
+
+	imx7d-sdb {
+		pinctrl_hog_2: hoggrp-2 {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO05__GPIO1_IO5	0x14
+				MX7D_PAD_EPDC_DATA14__GPIO2_IO14 0x59  /* CAN_STBY */
+				MX7D_PAD_GPIO1_IO00__WDOD1_WDOG_B 0x74
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX7D_PAD_GPIO1_IO01__PWM1_OUT	0x110b0
+			>;
+		};
+	};
+};
+
+&lcdif {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lcdif_dat
+		     &pinctrl_lcdif_ctrl>;
+	pinctrl-assert-gpios = <&gpio_spi 7 GPIO_ACTIVE_HIGH>;
+	display = <&display0>;
+	status = "okay";
+
+	display0: display {
+		bits-per-pixel = <16>;
+		bus-width = <24>;
+
+		display-timings {
+			native-mode = <&timing0>;
+			timing0: timing0 {
+			clock-frequency = <9200000>;
+			hactive = <480>;
+			vactive = <272>;
+			hfront-porch = <8>;
+			hback-porch = <4>;
+			hsync-len = <41>;
+			vback-porch = <2>;
+			vfront-porch = <4>;
+			vsync-len = <10>;
+
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <0>;
+			};
+		};
+	};
+};
+
+&pcie {
+	pinctrl-names = "default";
+	reset-gpio = <&gpio_spi 1 GPIO_ACTIVE_LOW>;
+	disable-gpio = <&gpio_spi 0 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&sai1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&clks IMX7D_SAI1_ROOT_SRC>,
+			  <&clks IMX7D_SAI1_ROOT_CLK>;
+	assigned-clock-parents = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
+	assigned-clock-rates = <0>, <36864000>;
+	status = "okay";
+};
+
+&sdma {
+	status = "okay";
+};
+
+&sim1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sim1_1>;
+	port = <0>;
+	sven_low_active;
+	status = "disabled";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clks IMX7D_UART1_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_OSC_24M_CLK>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	assigned-clocks = <&clks IMX7D_UART5_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_PLL_SYS_MAIN_240M_CLK>;
+	fsl,uart-has-rtscts;
+	/* for DTE mode, add below change */
+	/* fsl,dte-mode; */
+	/* pinctrl-0 = <&pinctrl_uart5dte>; */
+	status = "okay";
+};
+
+&uart6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart6>;
+	assigned-clocks = <&clks IMX7D_UART6_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_PLL_SYS_MAIN_240M_CLK>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg1_vbus>;
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	status = "okay";
+};
+
+&usbotg2 {
+	vbus-supply = <&reg_usb_otg2_vbus>;
+	dr_mode = "host";
+	status = "okay";
+};
+/*
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	cd-gpios = <&gpio5 0 0>;
+	wp-gpios = <&gpio5 1 0>;
+	tuning-step = <2>;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	enable-sdio-wakeup;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>;
+	enable-sdio-wakeup;
+	keep-power-in-suspend;
+	tuning-step = <2>;
+	wifi-host;
+	status = "okay";
+};
+*/
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	assigned-clocks = <&clks IMX7D_USDHC3_ROOT_CLK>;
+	assigned-clock-rates = <200000000>;
+	bus-width = <8>;
+	tuning-step = <2>;
+	non-removable;
+	status = "okay";
+};
diff --git a/arch/arm/configs/imx6_ea_android_defconfig b/arch/arm/configs/imx6_ea_android_defconfig
new file mode 100644
index 0000000..79546ac
--- /dev/null
+++ b/arch/arm/configs/imx6_ea_android_defconfig
@@ -0,0 +1,1110 @@
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_GPIO_PCA953X=y
+CONFIG_ARCH_MXC=y
+CONFIG_MACH_IMX51_DT=y
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_VF610=y
+CONFIG_MXC_REBOOT_ANDROID_CMD=y
+CONFIG_MX6_RAMOOPS=y
+CONFIG_MACH_IMX_BLUETOOTH_RFKILL=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_KSM=y
+CONFIG_CMA=y
+CONFIG_ZSMALLOC=y
+CONFIG_SECCOMP=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7D_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_NF_NAT_IPV6=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_LLC2=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_M_CAN=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_CFG80211=m
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+CONFIG_RFKILL_GPIO=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_MTD_UBI=y
+CONFIG_ZRAM=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_UID_STAT=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_DM_VERITY=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_MICREL_PHY=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_PEGASUS=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_CDC_EEM=y
+CONFIG_ATH_CARDS=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_BCMDHD=m
+CONFIG_BCMDHD_SDIO=y
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/bcm/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/firmware/bcm/bcmdhd.cal"
+CONFIG_BRCMFMAC=m
+CONFIG_RTL8821AS=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+CONFIG_TOUCHSCREEN_EGALAX=y
+CONFIG_TOUCHSCREEN_ELAN=y
+CONFIG_TOUCHSCREEN_MAX11801=y
+CONFIG_TOUCHSCREEN_IMX6UL_TSC=y
+CONFIG_TOUCHSCREEN_MC13783=y
+CONFIG_TOUCHSCREEN_TSC2007=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_INPUT_ISL29023=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_FSL_OTP=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=y
+CONFIG_I2C_ALGOPCA=y
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_74X164=y
+CONFIG_SABRESD_MAX8903=y
+CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_MAG3110=y
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MXC_HDMI_ANDROID=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_MAX17135=y
+CONFIG_MFD_SI476X_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_GSPCA=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=y
+CONFIG_MXC_CAMERA_OV5640=y
+CONFIG_MXC_CAMERA_OV5642=y
+CONFIG_MXC_CAMERA_OV5640_MIPI=y
+CONFIG_MXC_TVIN_ADV7180=y
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=y
+CONFIG_MXC_VADC=y
+CONFIG_MXC_MIPI_CSI=y
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_MX3=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=y
+CONFIG_RADIO_SI476X=y
+CONFIG_SOC_CAMERA_OV2640=y
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+CONFIG_FB=y
+CONFIG_FB_MXS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_EINK_V2_PANEL=y
+CONFIG_FB_MXS_SII902X=y
+CONFIG_FB_MXC_DCIC=y
+CONFIG_HANNSTAR_CABC=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_SII902X=y
+CONFIG_SND_SOC_IMX_WM8958=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_PRIMAX=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_USB_OTG_WAKELOCK=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MXC_IPU=y
+CONFIG_MXC_GPU_VIV=y
+CONFIG_GPU_LOW_MEMORY_KILLER=y
+CONFIG_MXC_IPU_V3_PRE=y
+CONFIG_MXC_MIPI_CSI2=y
+CONFIG_MXC_MLB150=y
+CONFIG_MXC_SIM=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_SYNC=y
+CONFIG_ION=y
+CONFIG_ION_MXC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_VF610_ADC=y
+CONFIG_AD2802A=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_DEBUG=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=y
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_FS_SECURITY=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_UTF8=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SINK_TPIU=y
+CONFIG_CORESIGHT_SINK_ETBV10=y
+CONFIG_CORESIGHT_SOURCE_ETM3X=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_LRW=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+
+
+
+CONFIG_PCI_QUIRKS=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_PCI_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+
+#
+# PCI host controller drivers
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCI_IMX6=y
+# CONFIG_PCI_IMX6SX_EXTREMELY_PWR_SAVE is not set
+# CONFIG_EP_MODE_IN_EP_RC_SYS is not set
+# CONFIG_RC_MODE_IN_EP_RC_SYS is not set
+# CONFIG_PCI_HOST_GENERIC is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+# CONFIG_PCH_CAN is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_CAFE is not set
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_CB710_CORE is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_NET_FC is not set
+# CONFIG_ARCNET is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX5_CORE is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MWL8K is not set
+# CONFIG_ATH5K is not set
+# CONFIG_ATH5K_PCI is not set
+# CONFIG_WIL6210 is not set
+# CONFIG_IPW2100 is not set
+CONFIG_IWLWIFI=m
+CONFIG_IWLDVM=m
+# CONFIG_IWLMVM is not set
+CONFIG_IWLWIFI_OPMODE_MODULAR=y
+
+#
+# Debugging Options
+#
+# CONFIG_IWLWIFI_DEBUG is not set
+# CONFIG_IWL4965 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_RTL8192CE is not set
+# CONFIG_RTL8192SE is not set
+# CONFIG_RTL8192DE is not set
+# CONFIG_RTL8723AE is not set
+# CONFIG_RTL8188EE is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_APPLICOM is not set
+CONFIG_DEVPORT=y
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDA_INTEL is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC_SDHCI_PCI is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_ET131X is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_R8821AE is not set
+# CONFIG_RTS5208 is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_VT6655 is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_SOLO6X10 is not set
+CONFIG_NET_VENDOR_SILICOM=y
+# CONFIG_SBYPASS is not set
+# CONFIG_BPCTL is not set
+# CONFIG_DGNC is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_PCI_MSI=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_RADIO_WL128X is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_IPW2200 is not set
+# CONFIG_HERMES is not set
+CONFIG_IWLMVM=m
+
+#
+# EA: Added for the sound codec
+#
+CONFIG_SND_SOC_IMX_WM8731=y
+
+#
+# EA: Possibly needed for CAN
+#
+CONFIG_CAN_VCAN=y
+CONFIG_CAN_DEBUG_DEVICES=y
+
+#
+# EA: Touch controller on Carrier Board
+#
+CONFIG_TOUCHSCREEN_AR1021_I2C=y
+
+#
+# EA: For USB Modem
+#
+CONFIG_USB_NET_RNDIS_HOST=m
+
+#
+# EA: Enable RPMsg Ping-pong demo
+#
+CONFIG_IMX_RPMSG_PINGPONG=m
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 039d9c2..fe9bcc5 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -136,6 +136,48 @@ static int __init imx6q_flexcan_fixup_auto(void)
 	return 0;
 }
 
+static void mx6qea_flexcan_switch(void)
+{
+	/* Polarity is inverted on the COM Carrier Board rev A */
+	if (flexcan0_en || flexcan1_en) {
+		gpio_set_value_cansleep(flexcan_en_gpio, 1);
+		gpio_set_value_cansleep(flexcan_en_gpio, 0);
+	} else {
+		gpio_set_value_cansleep(flexcan_en_gpio, 1);
+	}
+}
+
+static void imx6qea_flexcan0_switch_auto(int enable)
+{
+	flexcan0_en = enable;
+	mx6qea_flexcan_switch();
+}
+
+static void imx6qea_flexcan1_switch_auto(int enable)
+{
+	flexcan1_en = enable;
+	mx6qea_flexcan_switch();
+}
+
+static int __init imx6qea_flexcan_fixup_auto(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_path("/soc/aips-bus@02000000/can@02090000");
+	if (!np)
+		return -ENODEV;
+
+	flexcan_en_gpio = of_get_named_gpio(np, "trx-en-gpio", 0);
+	if (gpio_is_valid(flexcan_en_gpio) &&
+		!gpio_request_one(flexcan_en_gpio, GPIOF_DIR_OUT, "flexcan-trx-en")) {
+		/* flexcan 0 & 1 are using the same GPIOs for transceiver */
+		flexcan_pdata[0].transceiver_switch = imx6qea_flexcan0_switch_auto;
+		flexcan_pdata[1].transceiver_switch = imx6qea_flexcan1_switch_auto;
+	}
+
+	return 0;
+}
+
 /* For imx6q sabrelite board: set KSZ9021RN RGMII pad skew */
 static int ksz9021rn_phy_fixup(struct phy_device *phydev)
 {
@@ -516,6 +558,9 @@ static void __init imx6q_init_late(void)
 	if (of_machine_is_compatible("fsl,imx6q-sabreauto")
 		|| of_machine_is_compatible("fsl,imx6dl-sabreauto"))
 		imx6q_flexcan_fixup_auto();
+
+	if (of_machine_is_compatible("fsl,imx6qea-com"))
+		imx6qea_flexcan_fixup_auto();
 }
 
 static void __init imx6q_map_io(void)
diff --git a/arch/arm/mach-imx/mach-imx6sx.c b/arch/arm/mach-imx/mach-imx6sx.c
index eda08df..e38775e 100755
--- a/arch/arm/mach-imx/mach-imx6sx.c
+++ b/arch/arm/mach-imx/mach-imx6sx.c
@@ -166,6 +166,8 @@ static int __init imx6sx_arm2_flexcan_fixup(void)
 
 	if (of_machine_is_compatible("fsl,imx6sx-sdb") && canfd_en)
 		imx6sx_arm2_flexcan0_switch(1);
+	if (of_machine_is_compatible("fsl,imx6sxea-com") && canfd_en)
+		imx6sx_arm2_flexcan0_switch(1);
 
 	return 0;
 }
@@ -295,7 +297,8 @@ static void __init imx6sx_init_late(void)
 	}
 
 	if (of_machine_is_compatible("fsl,imx6sx-sdb") ||
-		of_machine_is_compatible("fsl,imx6sx-sabreauto"))
+		of_machine_is_compatible("fsl,imx6sx-sabreauto") ||
+		of_machine_is_compatible("fsl,imx6sxea-com"))
 		imx6sx_arm2_flexcan_fixup();
 
 	imx6sx_cpuidle_init();
diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c
index 4accb3a..e3d0fea 100644
--- a/arch/arm/mach-imx/mach-imx6ul.c
+++ b/arch/arm/mach-imx/mach-imx6ul.c
@@ -25,6 +25,60 @@
 #include "common.h"
 #include "cpuidle.h"
 
+static struct flexcan_platform_data flexcan_pdata[2];
+static int flexcan_en_gpio;
+static int flexcan_en_active_high;
+static int flexcan0_en;
+static int flexcan1_en;
+
+static void imx6ulea_flexcan_switch(void)
+{
+	if (flexcan0_en || flexcan1_en) {
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					!flexcan_en_active_high);
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					flexcan_en_active_high);
+	} else {
+		gpio_set_value_cansleep(flexcan_en_gpio,
+					!flexcan_en_active_high);
+	}
+}
+
+static void imx6ulea_flexcan0_switch(int enable)
+{
+	flexcan0_en = enable;
+	imx6ulea_flexcan_switch();
+}
+
+static void imx6ulea_flexcan1_switch(int enable)
+{
+	flexcan1_en = enable;
+	imx6ulea_flexcan_switch();
+}
+
+static int __init imx6ulea_flexcan_fixup(void)
+{
+	struct device_node *np;
+	enum of_gpio_flags en_flags, stby_flags;
+
+	np = of_find_node_by_path("/soc/aips-bus@02000000/can@02090000");
+	if (!np)
+		return -ENODEV;
+
+	flexcan_en_gpio = of_get_named_gpio_flags(np, "trx-en-gpio", 0, &en_flags);
+
+	if (gpio_is_valid(flexcan_en_gpio) && 
+		!gpio_request_one(flexcan_en_gpio, GPIOF_DIR_OUT, "flexcan-trx-en")) {
+		/* flexcan 0 & 1 are using the same GPIOs for transceiver */
+		flexcan_pdata[0].transceiver_switch = imx6ulea_flexcan0_switch;
+		flexcan_pdata[1].transceiver_switch = imx6ulea_flexcan1_switch;
+		if (!(en_flags & OF_GPIO_ACTIVE_LOW))
+			flexcan_en_active_high = 1;
+	}
+
+	return 0;
+}
+
 static void __init imx6ul_enet_clk_init(void)
 {
 	struct regmap *gpr;
@@ -99,6 +153,9 @@ static void __init imx6ul_init_late(void)
 {
 	platform_device_register_simple("imx6q-cpufreq", -1, NULL, 0);
 
+	if (of_machine_is_compatible("fsl,imx6ulea-com"))
+		imx6ulea_flexcan_fixup();
+
 	imx6ul_cpuidle_init();
 }
 
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 903f24d..dcf5f3d 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -626,6 +626,13 @@ config GPIO_ADNP
 	  enough to represent all pins, but the driver will assume a
 	  register layout for 64 pins (8 registers).
 
+config GPIO_BD7181X
+	tristate "BD7181X GPO"
+	depends on MFD_BD7181X
+	help
+	  Say yes here to access the GPO signals of bd71815/bd71817 chip from ROHM.
+
+
 comment "PCI GPIO expanders:"
 
 config GPIO_CS5535
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 5d50179..406a49f 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -99,3 +99,4 @@ obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
 obj-$(CONFIG_GPIO_XTENSA)	+= gpio-xtensa.o
+obj-$(CONFIG_GPIO_BD7181X)	+= gpio-bd7181x.o
diff --git a/drivers/gpio/gpio-bd7181x.c b/drivers/gpio/gpio-bd7181x.c
new file mode 100644
index 0000000..39ffe4c
--- /dev/null
+++ b/drivers/gpio/gpio-bd7181x.c
@@ -0,0 +1,201 @@
+/*
+ * gpio-bd7181x.c
+ * @file Access to GPOs on ROHM BD7181XMWV chip
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x gpio chip core data */
+static struct gpio_chip bd7181xgpo_chip;
+
+/** @brief get gpo output value
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181xgpo_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(chip->dev->parent);
+	int ret = 0;
+
+	ret = bd7181x_reg_read(bd7181x, BD7181X_REG_GPO);
+	if (ret < 0)
+		return ret;
+
+	return (ret >> offset) & 1;
+}
+
+/** @brief set gpo direction as output
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @param value output value when set direction out
+ * @retval 0 success
+ */
+static int bd7181xgpo_direction_out(struct gpio_chip *chip, unsigned offset,
+				    int value)
+{
+	/* This only drives GPOs, and can't change direction */
+	return 0;
+}
+
+/** @brief set gpo output value
+ * @param chip pointer to core data
+ * @param offset gpo number, start from 0
+ * @param value output value, not zero as high level, 0 as low level
+ * @retval 0 success
+ * @retval negative error number
+ */
+static void bd7181xgpo_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(chip->dev->parent);
+	int ret;
+	u8 gpoctl;
+
+	ret = bd7181x_reg_read(bd7181x, BD7181X_REG_GPO);
+	if (ret < 0)
+		return;
+
+	if (value)
+		gpoctl = ret | (1 << offset);
+	else
+		gpoctl = ret & ~(1 << offset);
+
+	bd7181x_reg_write(bd7181x, BD7181X_REG_GPO, gpoctl);
+}
+
+/** @brief bd7181x gpio chip core data */
+static struct gpio_chip bd7181xgpo_chip = {
+	.label			= "bd7181x",		///< gpio chip name
+	.owner			= THIS_MODULE,
+	.get			= bd7181xgpo_get,
+	.direction_output	= bd7181xgpo_direction_out,
+	.set			= bd7181xgpo_set,
+	.can_sleep		= 1,
+};
+
+/*----------------------------------------------------------------------*/
+#ifdef CONFIG_OF
+/** @brief retrive gpo platform data from device tree
+ * @param pdev platfrom device pointer
+ * @return pointer to platform data
+ * @retval NULL error
+ */
+static struct bd7181x_gpo_plat_data *of_gpio_bd7181x(
+	struct platform_device *pdev)
+{
+	struct bd7181x_gpo_plat_data *platform_data;
+	struct device_node *np, *gpio_np;
+
+	platform_data = devm_kzalloc(&pdev->dev, sizeof(*platform_data), GFP_KERNEL);
+	if (!platform_data) {
+		return NULL;
+	}
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	gpio_np = of_find_node_by_name(np, "gpo");
+	if (!gpio_np) {
+		dev_err(&pdev->dev, "gpio node not found\n");
+		return NULL;
+	}
+
+	pdev->dev.of_node = gpio_np;
+	
+	if (of_property_read_u32(gpio_np, "rohm,mode", &platform_data->mode)) {
+		platform_data->mode = -1;
+	}
+	
+	return platform_data;
+}
+#endif
+
+/** @brief probe bd7181x gpo device
+ * @param pdev platfrom device pointer
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int gpo_bd7181x_probe(struct platform_device *pdev)
+{
+	struct bd7181x_gpo_plat_data *pdata = pdev->dev.platform_data;
+	struct device *mfd_dev = pdev->dev.parent;
+	struct bd7181x *bd7181x = dev_get_drvdata(mfd_dev);
+	int ret;
+
+#ifdef CONFIG_OF
+	pdata = of_gpio_bd7181x(pdev);
+#endif
+	if (pdata && pdata->gpio_base > 0)
+		bd7181xgpo_chip.base = pdata->gpio_base;
+	else
+		bd7181xgpo_chip.base = -1;
+
+	bd7181xgpo_chip.ngpio = 2;	/* bd71815/bd71817 have 2 GPO */
+
+	bd7181xgpo_chip.dev = &pdev->dev;
+
+	ret = gpiochip_add(&bd7181xgpo_chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);
+		bd7181xgpo_chip.ngpio = 0;
+		return ret;
+	}
+
+	if (pdata && pdata->mode != -1UL) {
+		bd7181x_update_bits(bd7181x, BD7181X_REG_GPO, 0x70, pdata->mode);
+	}
+
+	return ret;
+}
+
+/** @brief remove bd7181x gpo device
+ * @param pdev platfrom device pointer
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int gpo_bd7181x_remove(struct platform_device *pdev)
+{
+	return gpiochip_remove(&bd7181xgpo_chip);
+}
+
+/* Note:  this hardware lives inside an I2C-based multi-function device. */
+MODULE_ALIAS("platform:bd7181x-gpo");
+
+/** @brief bd7181x gpo driver core data */
+static struct platform_driver gpo_bd7181x_driver = {
+	.driver = {
+		.name	= "bd7181x-gpo",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= gpo_bd7181x_probe,
+	.remove		= gpo_bd7181x_remove,
+};
+
+module_platform_driver(gpo_bd7181x_driver);
+
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("GPO interface for BD71815/BD71817");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index e013025..5964855 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -86,6 +86,18 @@ config TOUCHSCREEN_AD7879_SPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7879-spi.
 
+config TOUCHSCREEN_AR1021_I2C
+	tristate "Microchip AR1021 i2c touchscreen"
+	depends on I2C && OF
+	help
+	  Say Y here if you have the Microchip AR1021 touchscreen controller
+	  chip in your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ar1021_i2c.
+
 config TOUCHSCREEN_ATMEL_MXT
 	tristate "Atmel mXT I2C Touchscreen"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 88e481f..d846d5e 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_I2C)	+= ad7879-i2c.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879_SPI)	+= ad7879-spi.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
+obj-$(CONFIG_TOUCHSCREEN_AR1021_I2C)	+= ar1021_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_MXT)	+= atmel_mxt_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_TSADCC)	+= atmel_tsadcc.o
 obj-$(CONFIG_TOUCHSCREEN_AUO_PIXCIR)	+= auo-pixcir-ts.o
diff --git a/drivers/input/touchscreen/ar1021_i2c.c b/drivers/input/touchscreen/ar1021_i2c.c
new file mode 100644
index 0000000..c7dc0f0
--- /dev/null
+++ b/drivers/input/touchscreen/ar1021_i2c.c
@@ -0,0 +1,202 @@
+/*
+ * Microchip AR1021 driver for I2C
+ *
+ * Author: Christian Gmeiner <christian.gmeiner@gmail.com>
+ *
+ * License: GPLv2 as published by the FSF.
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#define AR1021_TOCUH_PKG_SIZE	5
+
+#define AR1021_MAX_X	4095
+#define AR1021_MAX_Y	4095
+
+struct ar1021_i2c {
+	struct i2c_client *client;
+	struct input_dev *input;
+	u8 data[AR1021_TOCUH_PKG_SIZE];
+	bool swap_xy;
+	bool invert_x;
+	bool invert_y;
+};
+
+static irqreturn_t ar1021_i2c_irq(int irq, void *dev_id)
+{
+	struct ar1021_i2c *ar1021 = dev_id;
+	struct input_dev *input = ar1021->input;
+	u8 *data = ar1021->data;
+	unsigned int x, y, button;
+	int retval;
+
+	retval = i2c_master_recv(ar1021->client,
+				ar1021->data, sizeof(ar1021->data));
+	if (retval != sizeof(ar1021->data))
+		goto out;
+
+	/* sync bit set ? */
+	if ((data[0] & 0x80) == 0)
+		goto out;
+
+	button = data[0] & BIT(0);
+	x = ((data[2] & 0x1f) << 7) | (data[1] & 0x7f);
+	y = ((data[4] & 0x1f) << 7) | (data[3] & 0x7f);
+
+	if (ar1021->swap_xy)
+		swap(x, y);
+	if (ar1021->invert_x)
+		x = AR1021_MAX_X - x;
+	if (ar1021->invert_y)
+		y = AR1021_MAX_Y - y;
+
+	input_report_abs(input, ABS_X, x);
+	input_report_abs(input, ABS_Y, y);
+	input_report_key(input, BTN_TOUCH, button);
+	input_sync(input);
+
+out:
+	return IRQ_HANDLED;
+}
+
+static int ar1021_i2c_open(struct input_dev *dev)
+{
+	struct ar1021_i2c *ar1021 = input_get_drvdata(dev);
+	struct i2c_client *client = ar1021->client;
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static void ar1021_i2c_close(struct input_dev *dev)
+{
+	struct ar1021_i2c *ar1021 = input_get_drvdata(dev);
+	struct i2c_client *client = ar1021->client;
+
+	disable_irq(client->irq);
+}
+
+static int ar1021_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	struct ar1021_i2c *ar1021;
+	struct input_dev *input;
+	struct device_node *np = client->dev.of_node;
+	int error;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "i2c_check_functionality error\n");
+		return -ENXIO;
+	}
+
+	ar1021 = devm_kzalloc(&client->dev, sizeof(*ar1021), GFP_KERNEL);
+	if (!ar1021)
+		return -ENOMEM;
+
+	input = devm_input_allocate_device(&client->dev);
+	if (!input)
+		return -ENOMEM;
+
+	if (!np)
+		return -ENODEV;
+
+	ar1021->client = client;
+	ar1021->input = input;
+	ar1021->swap_xy = of_property_read_bool(np, "ar1021,swap_xy");
+	ar1021->invert_x = of_property_read_bool(np, "ar1021,invert_x");
+	ar1021->invert_y = of_property_read_bool(np, "ar1021,invert_y");
+
+	input->name = "ar1021 I2C Touchscreen";
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+	input->open = ar1021_i2c_open;
+	input->close = ar1021_i2c_close;
+
+	__set_bit(EV_ABS, input->evbit);
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(BTN_TOUCH, input->keybit);
+
+	input_set_abs_params(input, ABS_X, 0, AR1021_MAX_X, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0, AR1021_MAX_Y, 0, 0);
+
+	input_set_drvdata(input, ar1021);
+
+	error = devm_request_threaded_irq(&client->dev, client->irq,
+					  NULL, ar1021_i2c_irq,
+					  IRQF_ONESHOT,
+					  "ar1021_i2c", ar1021);
+	if (error) {
+		dev_err(&client->dev,
+			"Failed to enable IRQ, error: %d\n", error);
+		return error;
+	}
+
+	/* Disable the IRQ, we'll enable it in ar1021_i2c_open() */
+	disable_irq(client->irq);
+
+	error = input_register_device(ar1021->input);
+	if (error) {
+		dev_err(&client->dev,
+			"Failed to register input device, error: %d\n", error);
+		return error;
+	}
+
+	i2c_set_clientdata(client, ar1021);
+	return 0;
+}
+
+static int __maybe_unused ar1021_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	disable_irq(client->irq);
+
+	return 0;
+}
+
+static int __maybe_unused ar1021_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ar1021_i2c_pm, ar1021_i2c_suspend, ar1021_i2c_resume);
+
+static const struct i2c_device_id ar1021_i2c_id[] = {
+	{ "MICROCHIP_AR1021_I2C", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ar1021_i2c_id);
+
+static const struct of_device_id ar1021_i2c_of_match[] = {
+	{ .compatible = "microchip,ar1021-i2c", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ar1021_i2c_of_match);
+
+static struct i2c_driver ar1021_i2c_driver = {
+	.driver	= {
+		.name	= "ar1021_i2c",
+		.owner	= THIS_MODULE,
+		.pm	= &ar1021_i2c_pm,
+		.of_match_table = ar1021_i2c_of_match,
+	},
+
+	.probe		= ar1021_i2c_probe,
+	.id_table	= ar1021_i2c_id,
+};
+module_i2c_driver(ar1021_i2c_driver);
+
+MODULE_AUTHOR("Christian Gmeiner <christian.gmeiner@gmail.com>");
+MODULE_DESCRIPTION("Microchip AR1021 I2C Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 459c14c..f3d1da4 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1215,6 +1215,14 @@ config MFD_STW481X
 	  in various ST Microelectronics and ST-Ericsson embedded
 	  Nomadik series.
 
+config MFD_BD7181X
+	bool "BD71815/BD71817 Power Management chip"
+	depends on I2C=y
+	select MFD_CORE
+	help
+	  if you say yes here you get support for the BD71815/BD71817
+	  Power Management chips.
+
 endmenu
 endif
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index c0aedc3..e75359c 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -168,3 +168,4 @@ obj-$(CONFIG_MFD_AS3711)	+= as3711.o
 obj-$(CONFIG_MFD_AS3722)	+= as3722.o
 obj-$(CONFIG_MFD_STW481X)	+= stw481x.o
 obj-$(CONFIG_MFD_MXC_HDMI)	+= mxc-hdmi-core.o
+obj-$(CONFIG_MFD_BD7181X)	+= bd7181x.o
diff --git a/drivers/mfd/bd7181x.c b/drivers/mfd/bd7181x.c
new file mode 100644
index 0000000..942b7fc
--- /dev/null
+++ b/drivers/mfd/bd7181x.c
@@ -0,0 +1,382 @@
+/*
+ * @file bd7181x.c  --  RoHM BD7181X/BD71817 mfd driver
+ * 
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author: Tony Luo <luofc@embedinfo.com>
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x irq resource */
+static struct resource rtc_resources[] = {
+	{
+		.start  = BD7181X_IRQ_ALARM_12,
+		.end    = BD7181X_IRQ_ALARM_12,
+		.flags  = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource power_resources[] = {
+	// irq# 0
+	{
+		.start	= BD7181X_IRQ_DCIN_03,
+		.end	= BD7181X_IRQ_DCIN_03,
+		.flags	= IORESOURCE_IRQ,
+	},
+	// irq# 1
+	{
+		.start	= BD7181X_IRQ_BAT_MON_08,
+		.end	= BD7181X_IRQ_BAT_MON_08,
+		.flags	= IORESOURCE_IRQ,
+	},
+	// irq# 2
+	{
+		.start	= BD7181X_IRQ_TEMPERATURE_11,
+		.end	= BD7181X_IRQ_TEMPERATURE_11,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+/** @brief bd7181x multi function cells */
+static struct mfd_cell bd7181x_mfd_cells[] = {
+	{
+		.name = "bd7181x-pmic",
+	},
+	{
+		.name = "bd7181x-power",
+		.num_resources = ARRAY_SIZE(power_resources),
+		.resources = &power_resources[0],
+	},
+	{
+		.name = "bd7181x-gpo",
+	},
+	{
+		.name = "bd7181x-rtc",
+		.num_resources = ARRAY_SIZE(rtc_resources),
+		.resources = &rtc_resources[0],
+	},
+};
+
+/** @brief bd7181x irqs */
+static const struct regmap_irq bd7181x_irqs[] = {
+	[BD7181X_IRQ_BUCK_01] = {
+		.mask = BD7181X_INT_EN_01_BUCKAST_MASK,
+		.reg_offset = 1,
+	},
+	[BD7181X_IRQ_DCIN_02] = {
+		.mask = BD7181X_INT_EN_02_DCINAST_MASK,
+		.reg_offset = 2,
+	},
+	[BD7181X_IRQ_DCIN_03] = {
+		.mask = BD7181X_INT_EN_03_DCINAST_MASK,
+		.reg_offset = 3,
+	},
+	[BD7181X_IRQ_VSYS_04] = {
+		.mask = BD7181X_INT_EN_04_VSYSAST_MASK,
+		.reg_offset = 4,
+	},
+	[BD7181X_IRQ_CHARGE_05] = {
+		.mask = BD7181X_INT_EN_05_CHGAST_MASK,
+		.reg_offset = 5,
+	},
+	[BD7181X_IRQ_BAT_06] = {
+		.mask = BD7181X_INT_EN_06_BATAST_MASK,
+		.reg_offset = 6,
+	},
+	[BD7181X_IRQ_BAT_MON_07] = {
+		.mask = BD7181X_INT_EN_07_BMONAST_MASK,
+		.reg_offset = 7,
+	},
+	[BD7181X_IRQ_BAT_MON_08] = {
+		.mask = BD7181X_INT_EN_08_BMONAST_MASK,
+		.reg_offset = 8,
+	},
+	[BD7181X_IRQ_BAT_MON_09] = {
+		.mask = BD7181X_INT_EN_09_BMONAST_MASK,
+		.reg_offset = 9,
+	},
+	[BD7181X_IRQ_BAT_MON_10] = {
+		.mask = BD7181X_INT_EN_10_BMONAST_MASK,
+		.reg_offset = 10,
+	},
+	[BD7181X_IRQ_TEMPERATURE_11] = {
+		.mask = BD7181X_INT_EN_11_TMPAST_MASK,
+		.reg_offset = 11,
+	},
+	[BD7181X_IRQ_ALARM_12] = {
+		.mask = BD7181X_INT_EN_12_ALMAST_MASK,
+		.reg_offset = 12,
+	},
+};
+
+/** @brief bd7181x irq chip definition */
+static struct regmap_irq_chip bd7181x_irq_chip = {
+	.name = "bd7181x",
+	.irqs = bd7181x_irqs,
+	.num_irqs = ARRAY_SIZE(bd7181x_irqs),
+	.num_regs = 13,
+	.irq_reg_stride = 1,
+	.status_base = BD7181X_REG_INT_STAT,
+	.mask_base = BD7181X_REG_INT_EN_01 - 1,
+	.mask_invert = true,
+	// .ack_base = BD7181X_REG_INT_STAT_00,
+};
+
+/** @brief bd7181x irq initialize 
+ *  @param bd7181x bd7181x device to init
+ *  @param bdinfo platform init data
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_irq_init(struct bd7181x *bd7181x, struct bd7181x_board* bdinfo) {
+	int irq;
+	int ret = 0;
+
+	if (!bdinfo) {
+		dev_warn(bd7181x->dev, "No interrupt support, no pdata\n");
+		return -EINVAL;
+	}
+	
+	irq = gpio_to_irq(bdinfo->gpio_intr);
+
+	bd7181x->chip_irq = irq;
+	printk("bd7181x->chip_irq=%d \n", bd7181x->chip_irq);
+	ret = regmap_add_irq_chip(bd7181x->regmap, bd7181x->chip_irq,
+		IRQF_ONESHOT | IRQF_TRIGGER_FALLING, bdinfo->irq_base,
+		&bd7181x_irq_chip, &bd7181x->irq_data);
+	if (ret < 0) {
+		dev_warn(bd7181x->dev, "Failed to add irq_chip %d\n", ret);
+	}
+	return ret;
+}
+
+/** @brief bd7181x irq initialize 
+ *  @param bd7181x bd7181x device to init
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_irq_exit(struct bd7181x *bd7181x)
+{
+	if (bd7181x->chip_irq > 0)
+		regmap_del_irq_chip(bd7181x->chip_irq, bd7181x->irq_data);
+	return 0;
+}
+
+/** @brief check whether volatile register 
+ *  @param dev kernel device pointer
+ *  @param reg register index
+ */
+static bool is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	// struct bd7181x *bd7181x = dev_get_drvdata(dev);
+
+	/*
+	 * Caching all regulator registers.
+	 */
+	return true;
+}
+
+/** @brief regmap configures */
+static const struct regmap_config bd7181x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_reg = is_volatile_reg,
+	.max_register = BD7181X_MAX_REGISTER - 1,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id bd7181x_of_match[] = {
+	{ .compatible = "rohm,bd71815", .data = (void *)0},
+	{ .compatible = "rohm,bd71817", .data = (void *)1},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bd7181x_of_match);
+
+
+/** @brief parse device tree data of bd7181x
+ *  @param client client object provided by system
+ *  @param chip_id return chip id back to caller
+ *  @return board initialize data
+ */
+static struct bd7181x_board *bd7181x_parse_dt(struct i2c_client *client,
+						int *chip_id)
+{
+	struct device_node *np = client->dev.of_node;
+	struct bd7181x_board *board_info;
+	unsigned int prop;
+	const struct of_device_id *match;
+	int r = 0;
+
+	match = of_match_device(bd7181x_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	*chip_id  = (int)match->data;
+
+	board_info = devm_kzalloc(&client->dev, sizeof(*board_info),
+			GFP_KERNEL);
+	if (!board_info) {
+		dev_err(&client->dev, "Failed to allocate pdata\n");
+		return NULL;
+	}
+
+	board_info->gpio_intr = of_get_named_gpio(np, "gpio_intr", 0);
+	if (!gpio_is_valid(board_info->gpio_intr)) {
+		dev_err(&client->dev, "no pmic intr pin available\n");
+		goto err_intr;
+	}
+
+	r = of_property_read_u32(np, "irq_base", &prop);
+	if (!r) {
+		board_info->irq_base = prop;
+	} else {
+		board_info->irq_base = -1;
+	}
+
+	return board_info;
+
+err_intr:
+	devm_kfree(&client->dev, board_info);
+	return NULL;
+}
+#else
+static inline
+struct bd7181x_board *bd7181x_parse_dt(struct i2c_client *client,
+					 int *chip_id)
+{
+	return NULL;
+}
+#endif
+
+/** @brief probe bd7181x device
+ *  @param i2c client object provided by system
+ *  @param id chip id
+ *  @retval 0 probe success
+ *  @retval negative error number
+ */
+static int bd7181x_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct bd7181x *bd7181x;
+	struct bd7181x_board *pmic_plat_data;
+	struct bd7181x_board *of_pmic_plat_data = NULL;
+	int chip_id = id->driver_data;
+	int ret = 0;
+
+	pmic_plat_data = dev_get_platdata(&i2c->dev);
+
+	if (!pmic_plat_data && i2c->dev.of_node) {
+		pmic_plat_data = bd7181x_parse_dt(i2c, &chip_id);
+		of_pmic_plat_data = pmic_plat_data;
+	}
+
+	if (!pmic_plat_data)
+		return -EINVAL;
+
+	bd7181x = kzalloc(sizeof(struct bd7181x), GFP_KERNEL);
+	if (bd7181x == NULL)
+		return -ENOMEM;
+
+	bd7181x->of_plat_data = of_pmic_plat_data;
+	i2c_set_clientdata(i2c, bd7181x);
+	bd7181x->dev = &i2c->dev;
+	bd7181x->i2c_client = i2c;
+	bd7181x->id = chip_id;
+	mutex_init(&bd7181x->io_mutex);
+
+	bd7181x->regmap = devm_regmap_init_i2c(i2c, &bd7181x_regmap_config);
+	if (IS_ERR(bd7181x->regmap)) {
+		ret = PTR_ERR(bd7181x->regmap);
+		dev_err(&i2c->dev, "regmap initialization failed: %d\n", ret);
+		return ret;
+	}
+
+	bd7181x_irq_init(bd7181x, of_pmic_plat_data);
+
+	ret = mfd_add_devices(bd7181x->dev, -1,
+			      bd7181x_mfd_cells, ARRAY_SIZE(bd7181x_mfd_cells),
+			      NULL, 0,
+			      regmap_irq_get_domain(bd7181x->irq_data));
+	if (ret < 0)
+		goto err;
+
+	return ret;
+
+err:
+	mfd_remove_devices(bd7181x->dev);
+	kfree(bd7181x);
+	return ret;
+}
+
+/** @brief remove bd7181x device
+ *  @param i2c client object provided by system
+ *  @return 0
+ */
+static int bd7181x_i2c_remove(struct i2c_client *i2c)
+{
+	struct bd7181x *bd7181x = i2c_get_clientdata(i2c);
+
+	bd7181x_irq_exit(bd7181x);
+	mfd_remove_devices(bd7181x->dev);
+	kfree(bd7181x);
+
+	return 0;
+}
+
+static const struct i2c_device_id bd7181x_i2c_id[] = {
+	{ "bd71815", 0 },
+	{ "bd71817", 1 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bd7181x_i2c_id);
+
+
+static struct i2c_driver bd7181x_i2c_driver = {
+	.driver = {
+		.name = "bd7181x",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(bd7181x_of_match),
+	},
+	.probe = bd7181x_i2c_probe,
+	.remove = bd7181x_i2c_remove,
+	.id_table = bd7181x_i2c_id,
+};
+
+static int __init bd7181x_i2c_init(void)
+{
+	return i2c_add_driver(&bd7181x_i2c_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(bd7181x_i2c_init);
+
+static void __exit bd7181x_i2c_exit(void)
+{
+	i2c_del_driver(&bd7181x_i2c_driver);
+}
+module_exit(bd7181x_i2c_exit);
+
+MODULE_AUTHOR("Tony Luo <luofc@embest-tech.com>");
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 chip multi-function driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 63a199b..614cc75 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -397,6 +397,13 @@ config BATTERY_GOLDFISH
 	  Say Y to enable support for the battery and AC power in the
 	  Goldfish emulator.
 
+
+config BD7181X_POWER
+        tristate "ROHM BD71815/BD71817 Charger for Battery and Adapter Power"
+        depends on MFD_BD7181X
+        help
+          Say Y to enable support for the BD71815/BD71817 charger.
+
 source "drivers/power/reset/Kconfig"
 
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index f98b373..0f4c833 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_POWER_AVS)		+= avs/
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
 obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_POWER_RESET)	+= reset/
+obj-$(CONFIG_BD7181X_POWER)	+= bd7181x-power.o
diff --git a/drivers/power/bd7181x-power.c b/drivers/power/bd7181x-power.c
new file mode 100644
index 0000000..9f7cdbf
--- /dev/null
+++ b/drivers/power/bd7181x-power.c
@@ -0,0 +1,2257 @@
+/*
+ * bd7181x-power.c
+ * @file ROHM BD71815/BD71817 Charger driver
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/bd7181x.h>
+#include <linux/delay.h>
+
+#if 0
+#define bd7181x_info	dev_info
+#else
+#define bd7181x_info(...)
+#endif
+
+#define JITTER_DEFAULT		3000		/* hope 3s is enough */
+#define JITTER_REPORT_CAP	10000		/* 10 seconds */
+#define BD7181X_BATTERY_CAP_MAH	910
+#define BD7181X_BATTERY_CAP	mAh_A10s(BD7181X_BATTERY_CAP_MAH)
+#define MAX_VOLTAGE		ocv_table[0]
+#define MIN_VOLTAGE		3400000
+#define THR_VOLTAGE		3800000
+#define MAX_CURRENT		890000		/* uA */
+#define AC_NAME			"bd7181x_ac"
+#define BAT_NAME		"bd7181x_bat"
+#define BD7181X_BATTERY_FULL	100
+
+#define BY_BAT_VOLT		0
+#define BY_VBATLOAD_REG		1
+#define INIT_COULOMB		BY_VBATLOAD_REG
+
+#define CALIB_CURRENT_A2A3	0xCE9E
+
+//VBAT Low voltage detection Threshold 
+#define VBAT_LOW_TH		0x00D4 // 0x00D4*16mV = 212*0.016 = 3.392v 
+
+#ifdef CONFIG_LAB126
+extern void usbotg_force_bsession(bool connected);
+#endif
+
+#define RS_30mOHM		/* This is for 30mOhm sense resistance */
+
+#ifdef RS_30mOHM
+#define A10s_mAh(s)		((s) * 1000 / (360 * 3))
+#define mAh_A10s(m)		((m) * (360 * 3) / 1000)
+#else
+#define A10s_mAh(s)		((s) * 1000 / 360)
+#define mAh_A10s(m)		((m) * 360 / 1000)
+#endif
+
+#define THR_RELAX_CURRENT	10		/* mA */
+#define THR_RELAX_TIME		(60 * 60)	/* sec. */
+
+#define BD7181X_DGRD_CYC_CAP	26	/* 1 micro Ah unit */
+
+#define BD7181X_DGRD_TEMP_M	25	/* 1 degrees C unit */
+#define BD7181X_DGRD_TEMP_L	5	/* 1 degrees C unit */
+#define BD7181X_DGRD_TEMP_CAP_H	(0)	/* 1 micro Ah unit */
+#define BD7181X_DGRD_TEMP_CAP_M	(1187)	/* 1 micro Ah unit */
+#define BD7181X_DGRD_TEMP_CAP_L	(5141)	/* 1 micro Ah unit */
+
+#define CANCEL_ADJ_COULOMB_SOC_H_1	700	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_L_1	550	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_H_2	350	/* unit 0.1% */
+#define CANCEL_ADJ_COULOMB_SOC_L_2	0	/* unit 0.1% */
+
+#define FORCE_ADJ_COULOMB_TEMP_H	35	/* 1 degrees C unit */
+#define FORCE_ADJ_COULOMB_TEMP_L	15	/* 1 degrees C unit */
+
+unsigned int battery_cycle;
+
+
+static int ocv_table[] = {
+	4200000,
+	4167456,
+	4109781,
+	4065242,
+	4025618,
+	3989877,
+	3958031,
+	3929302,
+	3900935,
+	3869637,
+	3838475,
+	3815196,
+	3799778,
+	3788385,
+	3779627,
+	3770675,
+	3755368,
+	3736049,
+	3713545,
+	3685118,
+	3645278,
+	3465599,
+	2830610
+};	/* unit 1 micro V */
+
+static int soc_table[] = {
+	1000,
+	1000,
+	950,
+	900,
+	850,
+	800,
+	750,
+	700,
+	650,
+	600,
+	550,
+	500,
+	450,
+	400,
+	350,
+	300,
+	250,
+	200,
+	150,
+	100,
+	50,
+	0,
+	-50
+	/* unit 0.1% */
+};
+
+
+/** @brief power deivce */
+struct bd7181x_power {
+	struct device *dev;
+	struct bd7181x *mfd;			/**< parent for access register */
+	struct power_supply ac;			/**< alternating current power */
+	struct power_supply bat;		/**< battery power */
+	struct delayed_work bd_work;		/**< delayed work for timed work */
+
+	int	reg_index;			/**< register address saved for sysfs */
+
+	int    vbus_status;			/**< last vbus status */
+	int    charge_status;			/**< last charge status */
+	int    bat_status;			/**< last bat status */
+
+	int	hw_ocv1;			/**< HW ocv1 */
+	int	hw_ocv2;			/**< HW ocv2 */
+	int	bat_online;			/**< battery connect */
+	int	charger_online;			/**< charger connect */
+	int	vcell;				/**< battery voltage */
+	int	vsys;				/**< system voltage */
+	int	vcell_min;			/**< minimum battery voltage */
+	int	vsys_min;			/**< minimum system voltage */
+	int	rpt_status;			/**< battery status report */
+	int	prev_rpt_status;		/**< previous battery status report */
+	int	bat_health;			/**< battery health */
+	int	designed_cap;			/**< battery designed capacity */
+	int	full_cap;			/**< battery capacity */
+	int	curr;				/**< battery current from DS-ADC */
+	int	curr_sar;			/**< battery current from VM_IBAT */
+	int	temp;				/**< battery tempature */
+	u32	coulomb_cnt;			/**< Coulomb Counter */
+	int	state_machine;			/**< initial-procedure state machine */
+
+	u32	soc_org;			/**< State Of Charge using designed capacity without by load */
+	u32	soc_norm;			/**< State Of Charge using full capacity without by load */
+	u32	soc;				/**< State Of Charge using full capacity with by load */
+	u32	clamp_soc;			/**< Clamped State Of Charge using full capacity with by load */
+
+	int	relax_time;			/**< Relax Time */
+
+	u32	cycle;				/**< Charging and Discharging cycle number */
+	volatile int calib_current;		/**< calibration current */
+};
+
+
+#define CALIB_NORM			0
+#define CALIB_START			1
+#define CALIB_GO			2
+
+enum {
+	STAT_POWER_ON,
+	STAT_INITIALIZED,
+};
+
+static int bd7181x_calc_soc_org(struct bd7181x_power* pwr);
+
+/** @brief read a register group once
+ *  @param mfd bd7181x device
+ *  @param reg	 register address of lower register
+ *  @return register value
+ */
+#ifdef __BD7181X_REGMAP_H__
+static u16 bd7181x_reg_read16(struct bd7181x* mfd, int reg) {
+	u16 v;
+
+	v = (u16)bd7181x_reg_read(mfd, reg) << 8;
+	v |= (u16)bd7181x_reg_read(mfd, reg + 1) << 0;
+	return v;
+}
+#else
+static u16 bd7181x_reg_read16(struct bd7181x* mfd, int reg) {
+	union {
+		u16 long_type;
+		char chars[2];
+	} u;
+	int r;
+
+	r = regmap_bulk_read(mfd->regmap, reg, u.chars, sizeof u.chars);
+	if (r) {
+		return -1;
+	}
+	return be16_to_cpu(u.long_type);
+}
+#endif
+
+/** @brief write a register group once
+ * @param mfd bd7181x device
+ * @param reg register address of lower register
+ * @param val value to write
+ * @retval 0 success
+ * @retval -1 fail
+ */
+static int bd7181x_reg_write16(struct bd7181x *mfd, int reg, u16 val) {
+	union {
+		u16 long_type;
+		char chars[2];
+	} u;
+	int r;
+
+	u.long_type = cpu_to_be16(val);
+	// printk("write16 0x%.4X 0x%.4X\n", val, u.long_type);
+#ifdef __BD7181X_REGMAP_H__
+	r = mfd->write(mfd, reg, sizeof u.chars, u.chars);
+#else
+	r = regmap_bulk_write(mfd->regmap, reg, u.chars, sizeof u.chars);
+#endif
+	if (r) {
+		return -1;
+	}
+	return 0;	
+}
+
+/** @brief read quad register once
+ *  @param mfd bd7181x device
+ *  @param reg	 register address of lower register
+ *  @return register value
+ */
+static int bd7181x_reg_read32(struct bd7181x *mfd, int reg) {
+	union {
+		u32 long_type;
+		char chars[4];
+	} u;
+	int r;
+
+#ifdef __BD7181X_REGMAP_H__
+	r = mfd->read(mfd, reg, sizeof u.chars, u.chars);
+#else
+	r = regmap_bulk_read(mfd->regmap, reg, u.chars, sizeof u.chars);
+#endif
+	if (r) {
+		return -1;
+	}
+	return be32_to_cpu(u.long_type);
+}
+
+#if 0
+/** @brief write quad register once
+ * @param mfd bd7181x device
+ * @param reg register address of lower register
+ * @param val value to write
+ * @retval 0 success
+ * @retval -1 fail
+ */
+static int bd7181x_reg_write32(struct bd7181x *mfd, int reg, unsigned val) {
+	union {
+		u32 long_type;
+		char chars[4];
+	} u;
+	int r;
+
+	u.long_type = cpu_to_be32(val);
+	r = regmap_bulk_write(mfd->regmap, reg, u.chars, sizeof u.chars);
+	if (r) {
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+#if INIT_COULOMB == BY_VBATLOAD_REG
+/** @brief get initial battery voltage and current
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_init_bat_stat(struct bd7181x_power *pwr) {
+	struct bd7181x *mfd = pwr->mfd;
+	int vcell;
+
+	vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_OCV_PRE_U) * 1000;
+	bd7181x_info(pwr->dev, "VM_OCV_PRE = %d\n", vcell);
+	pwr->hw_ocv1 = vcell;
+
+	vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_OCV_PST_U) * 1000;
+	bd7181x_info(pwr->dev, "VM_OCV_PST = %d\n", vcell);
+	pwr->hw_ocv2 = vcell;
+
+	return 0;
+}
+#endif
+
+/** @brief get battery average voltage and current
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @param curr  pointer to return back current in unit uA.
+ * @return 0
+ */
+static int bd7181x_get_vbat_curr(struct bd7181x_power *pwr, int *vcell, int *curr) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell, tmp_curr;
+
+	tmp_vcell = 0;
+	tmp_curr = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VBAT_U);
+	tmp_curr = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_IBAT_U);
+	if (tmp_curr & IBAT_SA_DIR_Discharging) {
+		tmp_curr = -(tmp_curr & ~IBAT_SA_DIR_Discharging);
+	}
+
+	*vcell = tmp_vcell * 1000;
+#ifdef RS_30mOHM
+	*curr = tmp_curr * 1000 / 3;
+#else
+	*curr = tmp_curr * 1000;
+#endif
+	return 0;
+}
+
+/** @brief get battery current from DS-ADC
+ * @param pwr power device
+ * @return current in unit uA
+ */
+static int bd7181x_get_current_ds_adc(struct bd7181x_power *pwr) {
+	int r;
+	
+	r = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_CURCD_U);
+	if (r < 0) {
+		return 0;
+	}
+	if (r & CURDIR_Discharging) {
+		r = -(r & ~CURDIR_Discharging);
+	}
+#ifdef RS_30mOHM
+	return r * 1000 / 3;
+#else
+	return r * 1000;
+#endif
+}
+
+/** @brief get system average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vsys(struct bd7181x_power *pwr, int *vsys) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vsys;
+
+	tmp_vsys = 0;
+
+	tmp_vsys = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VSYS_U);
+
+	*vsys = tmp_vsys * 1000;
+
+	return 0;
+}
+
+/** @brief get battery minimum average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vbat_min(struct bd7181x_power *pwr, int *vcell) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell;
+
+	tmp_vcell = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VBAT_MIN_U);
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_VM_SA_MINMAX_CLR, VBAT_SA_MIN_CLR);
+
+	*vcell = tmp_vcell * 1000;
+
+	return 0;
+}
+
+/** @brief get system minimum average voltage
+ * @param pwr power device
+ * @param vcell pointer to return back voltage in unit uV.
+ * @return 0
+ */
+static int bd7181x_get_vsys_min(struct bd7181x_power *pwr, int *vcell) {
+	struct bd7181x* mfd = pwr->mfd;
+	int tmp_vcell;
+
+	tmp_vcell = 0;
+
+	tmp_vcell = bd7181x_reg_read16(mfd, BD7181X_REG_VM_SA_VSYS_MIN_U);
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_VM_SA_MINMAX_CLR, VSYS_SA_MIN_CLR);
+
+	*vcell = tmp_vcell * 1000;
+
+	return 0;
+}
+
+/** @brief get battery capacity
+ * @param ocv open circuit voltage
+ * @return capcity in unit 0.1 percent
+ */
+static int bd7181x_voltage_to_capacity(int ocv) {
+	int i = 0;
+	int soc;
+
+	if (ocv > ocv_table[0]) {
+		soc = soc_table[0];
+	} else {
+		i = 0;
+		while (soc_table[i] != -50) {
+			if ((ocv <= ocv_table[i]) && (ocv > ocv_table[i+1])) {
+				soc = (soc_table[i] - soc_table[i+1]) * (ocv - ocv_table[i+1]) / (ocv_table[i] - ocv_table[i+1]);
+				soc += soc_table[i+1];
+				break;
+			}
+			i++;
+		}
+		if (soc_table[i] == -50)
+			soc = soc_table[i];
+	}
+	return soc;
+}
+
+/** @brief get battery temperature
+ * @param pwr power device
+ * @return temperature in unit deg.Celsius
+ */
+static int bd7181x_get_temp(struct bd7181x_power *pwr) {
+	struct bd7181x* mfd = pwr->mfd;
+	int t;
+
+	t = 200 - (int)bd7181x_reg_read(mfd, BD7181X_REG_VM_BTMP);
+
+	// battery temperature error
+	t = (t > 200)? 200: t;
+	
+	return t;
+}
+
+static int bd7181x_reset_coulomb_count(struct bd7181x_power* pwr);
+
+/** @brief get battery charge status
+ * @param pwr power device
+ * @return temperature in unit deg.Celsius
+ */
+static int bd7181x_charge_status(struct bd7181x_power *pwr)
+{
+	u8 state;
+	int ret = 1;
+
+	state = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	// bd7181x_info(pwr->dev, "CHG_STATE %d\n", state);
+
+	switch (state) {
+	case 0x00:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x01:
+	case 0x02:
+	case 0x03:
+	case 0x0E:
+		pwr->rpt_status = POWER_SUPPLY_STATUS_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x0F:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_FULL;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x10:
+	case 0x11:
+	case 0x12:
+	case 0x13:
+	case 0x14:
+	case 0x20:
+	case 0x21:
+	case 0x22:
+	case 0x23:
+	case 0x24:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_OVERHEAT;
+		break;
+	case 0x30:
+	case 0x31:
+	case 0x32:
+	case 0x40:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case 0x7f:
+	default:
+		ret = 0;
+		pwr->rpt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		pwr->bat_health = POWER_SUPPLY_HEALTH_DEAD;
+		break;	
+	}
+
+	bd7181x_reset_coulomb_count(pwr);
+
+	pwr->prev_rpt_status = pwr->rpt_status;
+
+	return ret;
+}
+
+#if INIT_COULOMB == BY_BAT_VOLT
+static int bd7181x_calib_voltage(struct bd7181x_power* pwr, int* ocv) {
+	int r, curr, volt;
+
+	bd7181x_get_vbat_curr(pwr, &volt, &curr);
+
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	if (r >= 0 && curr > 0) {
+		// voltage increment caused by battery inner resistor
+		if (r == 3) volt -= 100 * 1000;
+		else if (r == 2) volt -= 50 * 1000;
+	}
+	*ocv = volt;
+
+	return 0;
+}
+#endif
+
+/** @brief set initial coulomb counter value from battery voltage
+ * @param pwr power device
+ * @return 0
+ */
+static int calibration_coulomb_counter(struct bd7181x_power* pwr) {
+	u32 bcap;
+	int soc, ocv;
+
+#if INIT_COULOMB == BY_VBATLOAD_REG
+	/* Get init OCV by HW */
+	bd7181x_get_init_bat_stat(pwr);
+
+	ocv = (pwr->hw_ocv1 >= pwr->hw_ocv2)? pwr->hw_ocv1: pwr->hw_ocv2;
+	bd7181x_info(pwr->dev, "ocv %d\n", ocv);
+#elif INIT_COULOMB == BY_BAT_VOLT
+	bd7181x_calib_voltage(pwr, &ocv);
+#endif
+
+	/* Get init soc from ocv/soc table */
+	soc = bd7181x_voltage_to_capacity(ocv);
+	bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+	if (soc < 0)
+		soc = 0;
+	bcap = pwr->designed_cap * soc / 1000;
+
+	bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+	bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+	pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+	bd7181x_info(pwr->dev, "%s() CC_CCNTD = %d\n", __func__, pwr->coulomb_cnt);
+
+	/* Start canceling offset of the DS ADC. This needs 1 second at least */
+	bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCCALIB);
+
+	return 0;
+}
+
+/** @brief adjust coulomb counter values at relaxed state
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_adjust_coulomb_count(struct bd7181x_power* pwr) {
+	u32 relaxed_coulomb_cnt;
+
+	relaxed_coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_REX_CCNTD_3) & 0x1FFFFFFFUL;
+	if (relaxed_coulomb_cnt != 0) {
+		u32 bcap;
+		int soc, ocv;
+		int diff_coulomb_cnt;
+
+		/* Get OCV at relaxed state by HW */
+		ocv = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_REX_SA_VBAT_U) * 1000;
+		bd7181x_info(pwr->dev, "ocv %d\n", ocv);
+
+		/* Clear Relaxed Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_REX_CTRL_1, REX_CLR);
+
+		diff_coulomb_cnt = relaxed_coulomb_cnt - (bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL);
+		diff_coulomb_cnt = diff_coulomb_cnt >> 16;
+		bd7181x_info(pwr->dev, "diff_coulomb_cnt = %d\n", diff_coulomb_cnt);
+
+		/* Get soc at relaxed state from ocv/soc table */
+		soc = bd7181x_voltage_to_capacity(ocv);
+		bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+		if (soc < 0)
+			soc = 0;
+
+		if ((soc > CANCEL_ADJ_COULOMB_SOC_H_1) || ((soc < CANCEL_ADJ_COULOMB_SOC_L_1) && (soc > CANCEL_ADJ_COULOMB_SOC_H_2)) || (soc < CANCEL_ADJ_COULOMB_SOC_L_2) || 
+			((pwr->temp <= FORCE_ADJ_COULOMB_TEMP_H) && (pwr->temp >= FORCE_ADJ_COULOMB_TEMP_L))) {
+			bcap = pwr->designed_cap * soc / 1000;
+
+			/* Stop Coulomb Counter */
+			bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL) + diff_coulomb_cnt);
+
+			pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+			bd7181x_info(pwr->dev, "Adjust Coulomb Counter at Relaxed State\n");
+			bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+			/* Start Coulomb Counter */
+			bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			/* If the following commented out code is enabled, the SOC is not clamped at the relax time. */
+			/* Reset SOCs */
+			/* bd7181x_calc_soc_org(pwr); */
+			/* pwr->soc_norm = pwr->soc_org; */
+			/* pwr->soc = pwr->soc_norm; */
+			/* pwr->clamp_soc = pwr->soc; */
+		}
+	}
+
+	return 0;
+}
+
+/** @brief reset coulomb counter values at full charged state
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_reset_coulomb_count(struct bd7181x_power* pwr)
+{
+	u32 full_charged_coulomb_cnt;
+
+	full_charged_coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_FULL_CCNTD_3) & 0x1FFFFFFFUL;
+	if (full_charged_coulomb_cnt != 0) {
+		int diff_coulomb_cnt;
+
+		/* Clear Full Charged Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_FULL_CTRL, FULL_CLR);
+
+		diff_coulomb_cnt = full_charged_coulomb_cnt - (bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL);
+		diff_coulomb_cnt = diff_coulomb_cnt >> 16;
+		if (diff_coulomb_cnt > 0) {
+			diff_coulomb_cnt = 0;
+		}
+		bd7181x_info(pwr->dev, "diff_coulomb_cnt = %d\n", diff_coulomb_cnt);
+
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((pwr->designed_cap + pwr->designed_cap / 200) & 0x1FFFUL) + diff_coulomb_cnt);
+
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		bd7181x_info(pwr->dev, "Reset Coulomb Counter at POWER_SUPPLY_STATUS_FULL\n");
+		bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+
+	return 0;
+}
+
+/** @brief get battery parameters, such as voltages, currents, temperatures.
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_voltage_current(struct bd7181x_power* pwr)
+{
+
+	/* Read detailed vcell and current */
+	bd7181x_get_vbat_curr(pwr, &pwr->vcell, &pwr->curr_sar);
+	bd7181x_info(pwr->dev, "VM_VBAT = %d\n", pwr->vcell);
+	bd7181x_info(pwr->dev, "VM_IBAT = %d\n", pwr->curr_sar);
+
+	pwr->curr = bd7181x_get_current_ds_adc(pwr);
+	bd7181x_info(pwr->dev, "CC_CURCD = %d\n", pwr->curr);
+
+	/* Read detailed vsys */
+	bd7181x_get_vsys(pwr, &pwr->vsys);
+	bd7181x_info(pwr->dev, "VM_VSYS = %d\n", pwr->vsys);
+
+	/* Read detailed vbat_min */
+	bd7181x_get_vbat_min(pwr, &pwr->vcell_min);
+	bd7181x_info(pwr->dev, "VM_VBAT_MIN = %d\n", pwr->vcell_min);
+
+	/* Read detailed vsys_min */
+	bd7181x_get_vsys_min(pwr, &pwr->vsys_min);
+	bd7181x_info(pwr->dev, "VM_VSYS_MIN = %d\n", pwr->vsys_min);
+
+	/* Get tempature */
+	pwr->temp = bd7181x_get_temp(pwr);
+	// bd7181x_info(pwr->dev, "Temperature %d degrees C\n", pwr->temp);
+
+	return 0;
+}
+
+/** @brief adjust coulomb counter values at relaxed state by SW
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_adjust_coulomb_count_sw(struct bd7181x_power* pwr)
+{
+	int tmp_curr_mA;
+
+	tmp_curr_mA = pwr->curr / 1000;
+	if ((tmp_curr_mA * tmp_curr_mA) <= (THR_RELAX_CURRENT * THR_RELAX_CURRENT)) { /* No load */
+		pwr->relax_time += (JITTER_DEFAULT / 1000);
+	}
+	else {
+		pwr->relax_time = 0;
+	}
+	
+	if (pwr->relax_time >= THR_RELAX_TIME) { /* Battery is relaxed. */
+		u32 bcap;
+		int soc, ocv;
+
+		pwr->relax_time = 0;
+
+		/* Get OCV */
+		ocv = pwr->vcell;
+
+		/* Get soc at relaxed state from ocv/soc table */
+		soc = bd7181x_voltage_to_capacity(ocv);
+		bd7181x_info(pwr->dev, "soc %d[0.1%%]\n", soc);
+		if (soc < 0)
+			soc = 0;
+
+		if ((soc > CANCEL_ADJ_COULOMB_SOC_H_1) || ((soc < CANCEL_ADJ_COULOMB_SOC_L_1) && (soc > CANCEL_ADJ_COULOMB_SOC_H_2)) || (soc < CANCEL_ADJ_COULOMB_SOC_L_2) || 
+			((pwr->temp <= FORCE_ADJ_COULOMB_TEMP_H) && (pwr->temp >= FORCE_ADJ_COULOMB_TEMP_L))) {
+			bcap = pwr->designed_cap * soc / 1000;
+
+			/* Stop Coulomb Counter */
+			bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+			bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((bcap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+			pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+			bd7181x_info(pwr->dev, "Adjust Coulomb Counter by SW at Relaxed State\n");
+			bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+			/* Start Coulomb Counter */
+			bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+			/* If the following commented out code is enabled, the SOC is not clamped at the relax time. */
+			/* Reset SOCs */
+			/* bd7181x_calc_soc_org(pwr); */
+			/* pwr->soc_norm = pwr->soc_org; */
+			/* pwr->soc = pwr->soc_norm; */
+			/* pwr->clamp_soc = pwr->soc; */
+		}
+
+	}
+
+	return 0;
+}
+
+/** @brief get coulomb counter values
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_coulomb_count(struct bd7181x_power* pwr) {
+	if (pwr->state_machine == STAT_POWER_ON) {
+		pwr->state_machine = STAT_INITIALIZED;
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	} else if (pwr->state_machine == STAT_INITIALIZED) {
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		// bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+	}
+	return 0;
+}
+
+/** @brief calc cycle
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_update_cycle(struct bd7181x_power* pwr) {
+	int charged_coulomb_cnt;
+
+	charged_coulomb_cnt = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CCNTD_CHG_3);
+	if (charged_coulomb_cnt >= pwr->designed_cap) {
+		pwr->cycle++;
+		bd7181x_info(pwr->dev, "Update cycle = %d\n", pwr->cycle);
+		battery_cycle = pwr->cycle;
+		charged_coulomb_cnt -= pwr->designed_cap;
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CCNTD_CHG_3, charged_coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+	return 0;
+}
+
+/** @brief calc full capacity value by Cycle and Temperature
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_full_cap(struct bd7181x_power* pwr) {
+	u32 designed_cap_uAh;
+	u32 full_cap_uAh;
+
+	/* Calculate full capacity by cycle */
+	designed_cap_uAh = A10s_mAh(pwr->designed_cap) * 1000;
+	full_cap_uAh = designed_cap_uAh - BD7181X_DGRD_CYC_CAP * pwr->cycle;
+	pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	bd7181x_info(pwr->dev, "Calculate full capacity by cycle\n");
+	bd7181x_info(pwr->dev, "%s() pwr->full_cap = %d\n", __func__, pwr->full_cap);
+
+	/* Calculate full capacity by temperature */
+	bd7181x_info(pwr->dev, "Temperature = %d\n", pwr->temp);
+	if (pwr->temp >= BD7181X_DGRD_TEMP_M) {
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_H;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	else if (pwr->temp >= BD7181X_DGRD_TEMP_L) {
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_M;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	else {
+		full_cap_uAh += (BD7181X_DGRD_TEMP_L - BD7181X_DGRD_TEMP_M) * BD7181X_DGRD_TEMP_CAP_M;
+		full_cap_uAh += (pwr->temp - BD7181X_DGRD_TEMP_L) * BD7181X_DGRD_TEMP_CAP_L;
+		pwr->full_cap = mAh_A10s(full_cap_uAh / 1000);
+	}
+	bd7181x_info(pwr->dev, "Calculate full capacity by cycle and temperature\n");
+	bd7181x_info(pwr->dev, "%s() pwr->full_cap = %d\n", __func__, pwr->full_cap);
+
+	return 0;
+}
+
+/** @brief calculate SOC values by designed capacity
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_soc_org(struct bd7181x_power* pwr) {
+	pwr->soc_org = (pwr->coulomb_cnt >> 16) * 100 /  pwr->designed_cap;
+	if (pwr->soc_org > 100) {
+		pwr->soc_org = 100;
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_1, 0);
+		bd7181x_reg_write16(pwr->mfd, BD7181X_REG_CC_CCNTD_3, ((pwr->designed_cap + pwr->designed_cap / 200) & 0x1FFFUL));
+
+		pwr->coulomb_cnt = bd7181x_reg_read32(pwr->mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+		bd7181x_info(pwr->dev, "Limit Coulomb Counter\n");
+		bd7181x_info(pwr->dev, "CC_CCNTD = %d\n", pwr->coulomb_cnt);
+
+		/* Start Coulomb Counter */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+	}
+		bd7181x_info(pwr->dev, "%s() pwr->soc_org = %d\n", __func__, pwr->soc_org);
+	return 0;
+}
+
+/** @brief calculate SOC values by full capacity
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_calc_soc_norm(struct bd7181x_power* pwr) {
+	int lost_cap;
+	int mod_coulomb_cnt;
+
+	lost_cap = pwr->designed_cap - pwr->full_cap;
+	bd7181x_info(pwr->dev, "%s() lost_cap = %d\n", __func__, lost_cap);
+	mod_coulomb_cnt = (pwr->coulomb_cnt >> 16) - lost_cap;
+	if ((mod_coulomb_cnt > 0) && (pwr->full_cap > 0)) {
+		pwr->soc_norm = mod_coulomb_cnt * 100 /  pwr->full_cap;
+	}
+	else {
+		pwr->soc_norm = 0;
+	}
+	if (pwr->soc_norm > 100) {
+		pwr->soc_norm = 100;
+	}
+		bd7181x_info(pwr->dev, "%s() pwr->soc_norm = %d\n", __func__, pwr->soc_norm);
+	return 0;
+}
+
+/** @brief get OCV value by SOC
+ * @param pwr power device
+ * @return 0
+ */
+int bd7181x_get_ocv(struct bd7181x_power* pwr, int dsoc) {
+	int i = 0;
+	int ocv = 0;
+
+	if (dsoc > soc_table[0]) {
+		ocv = MAX_VOLTAGE;
+	}
+	else if (dsoc == 0) {
+			ocv = ocv_table[21];
+	}
+	else {
+		i = 0;
+		while (i < 22) {
+			if ((dsoc <= soc_table[i]) && (dsoc > soc_table[i+1])) {
+				ocv = (ocv_table[i] - ocv_table[i+1]) * (dsoc - soc_table[i+1]) / (soc_table[i] - soc_table[i+1]) + ocv_table[i+1];
+				break;
+			}
+			i++;
+		}
+		if (i == 22)
+			ocv = ocv_table[22];
+	}
+	bd7181x_info(pwr->dev, "%s() ocv = %d\n", __func__, ocv);
+	return ocv;
+}
+
+/** @brief calculate SOC value by full_capacity and load
+ * @param pwr power device
+ * @return OCV
+ */
+static int bd7181x_calc_soc(struct bd7181x_power* pwr) {
+	int ocv_table_load[23];
+
+	pwr->soc = pwr->soc_norm;
+
+	switch (pwr->rpt_status) { /* Adjust for 0% between THR_VOLTAGE and MIN_VOLTAGE */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->vsys_min <= THR_VOLTAGE) {
+			int i;
+			int ocv;
+			int lost_cap;
+			int mod_coulomb_cnt;
+			int dsoc;
+
+			lost_cap = pwr->designed_cap - pwr->full_cap;
+			mod_coulomb_cnt = (pwr->coulomb_cnt >> 16) - lost_cap;
+			dsoc = mod_coulomb_cnt * 1000 /  pwr->full_cap;
+			bd7181x_info(pwr->dev, "%s() dsoc = %d\n", __func__, dsoc);
+			ocv = bd7181x_get_ocv(pwr, dsoc);
+			for (i = 1; i < 23; i++) {
+				ocv_table_load[i] = ocv_table[i] - (ocv - pwr->vsys_min);
+				if (ocv_table_load[i] <= MIN_VOLTAGE) {
+					bd7181x_info(pwr->dev, "%s() ocv_table_load[%d] = %d\n", __func__, i, ocv_table_load[i]);
+					break;
+				}
+			}
+			if (i < 23) {
+				int j;
+				int dv = (ocv_table_load[i-1] - ocv_table_load[i]) / 5;
+				int lost_cap2;
+				int mod_coulomb_cnt2, mod_full_cap;
+				for (j = 1; j < 5; j++){
+					if ((ocv_table_load[i] + dv * j) > MIN_VOLTAGE) {
+						break;
+					}
+				}
+				lost_cap2 = ((21 - i) * 5 + (j - 1)) * pwr->full_cap / 100;
+				bd7181x_info(pwr->dev, "%s() lost_cap2 = %d\n", __func__, lost_cap2);
+				mod_coulomb_cnt2 = mod_coulomb_cnt - lost_cap2;
+				mod_full_cap = pwr->full_cap - lost_cap2;
+				if ((mod_coulomb_cnt2 > 0) && (mod_full_cap > 0)) {
+					pwr->soc = mod_coulomb_cnt2 * 100 / mod_full_cap;
+				}
+				else {
+					pwr->soc = 0;
+				}
+				bd7181x_info(pwr->dev, "%s() pwr->soc(by load) = %d\n", __func__, pwr->soc);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (pwr->rpt_status) {/* Adjust for 0% and 100% */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->vsys_min <= MIN_VOLTAGE) {
+			pwr->soc = 0;
+		}
+		else {
+			if (pwr->soc == 0) {
+				pwr->soc = 1;
+			}
+		}
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		if (pwr->soc == 100) {
+			pwr->soc = 99;
+		}
+		break;
+	default:
+		break;
+	}
+	bd7181x_info(pwr->dev, "%s() pwr->soc = %d\n", __func__, pwr->soc);
+	return 0;
+}
+
+/** @brief calculate Clamped SOC value by full_capacity and load
+ * @param pwr power device
+ * @return OCV
+ */
+static int bd7181x_calc_soc_clamp(struct bd7181x_power* pwr) {
+	switch (pwr->rpt_status) {/* Adjust for 0% and 100% */
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (pwr->soc <= pwr->clamp_soc) {
+			pwr->clamp_soc = pwr->soc;
+		}
+		break;
+	default:
+		pwr->clamp_soc = pwr->soc;
+		break;
+	}
+	bd7181x_info(pwr->dev, "%s() pwr->clamp_soc = %d\n", __func__, pwr->clamp_soc);
+	return 0;
+}
+
+/** @brief get battery and DC online status
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_get_online(struct bd7181x_power* pwr) {
+	int r;
+
+#if 0
+#define TS_THRESHOLD_VOLT	0xD9
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_VM_VTH);
+	pwr->bat_online = (r > TS_THRESHOLD_VOLT);
+#endif
+#if 0
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+	if (r >= 0 && (r & BAT_DET_DONE)) {
+		pwr->bat_online = (r & BAT_DET) != 0;
+	}
+#endif
+#if 1
+#define BAT_OPEN	0x7
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_TEMP);
+	pwr->bat_online = (r != BAT_OPEN);
+#endif	
+	r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_DCIN_STAT);
+	if (r >= 0) {
+		pwr->charger_online = (r & VBUS_DET) != 0;
+	}
+
+	return 0;
+}
+
+/** @brief init bd7181x sub module charger
+ * @param pwr power device
+ * @return 0
+ */
+static int bd7181x_init_hardware(struct bd7181x_power *pwr)
+{
+	struct bd7181x *mfd = pwr->mfd;
+	int r;
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_DCIN_CLPS, 0x36);
+
+#define XSTB		0x02
+	r = bd7181x_reg_read(mfd, BD7181X_REG_CONF);
+
+#if 0
+	for (i = 0; i < 300; i++) {
+		r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+		if (r >= 0 && (r & BAT_DET_DONE)) {
+			break;
+		}
+		msleep(5);
+	}
+#endif
+	if ((r & XSTB) == 0x00) {
+	//if (r & BAT_DET) {
+		/* Init HW, when the battery is inserted. */
+
+		bd7181x_reg_write(mfd, BD7181X_REG_CONF, r | XSTB);
+
+#define TEST_SEQ_00		0x00
+#define TEST_SEQ_01		0x76
+#define TEST_SEQ_02		0x66
+#define TEST_SEQ_03		0x56
+#if 0
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+		bd7181x_reg_write16(pwr->mfd, 0xA2, CALIB_CURRENT_A2A3);
+		bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+#endif
+
+		/* Stop Coulomb Counter */
+		bd7181x_clear_bits(mfd, BD7181X_REG_CC_CTRL, CCNTENB);
+
+		/* Set Coulomb Counter Reset bit*/
+		bd7181x_set_bits(mfd, BD7181X_REG_CC_CTRL, CCNTRST);
+
+		/* Clear Coulomb Counter Reset bit*/
+		bd7181x_clear_bits(mfd, BD7181X_REG_CC_CTRL, CCNTRST);
+
+		/* Set default Battery Capacity */
+		pwr->designed_cap = BD7181X_BATTERY_CAP;
+		pwr->full_cap = BD7181X_BATTERY_CAP;
+
+		/* Set initial Coulomb Counter by HW OCV */
+		calibration_coulomb_counter(pwr);
+
+		/* WDT_FST auto set */
+		bd7181x_set_bits(mfd, BD7181X_REG_CHG_SET1, WDT_AUTO);
+
+		/* VBAT Low voltage detection Setting, added by John Zhang*/
+		bd7181x_reg_write16(mfd, BD7181X_REG_ALM_VBAT_TH_U, VBAT_LOW_TH); 
+
+		/* Mask Relax decision by PMU STATE */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_REX_CTRL_1, REX_PMU_STATE_MASK);
+
+		/* Set Battery Capacity Monitor threshold1 as 90% */
+		bd7181x_reg_write16(mfd, BD7181X_REG_CC_BATCAP1_TH_U, (BD7181X_BATTERY_CAP * 9 / 10)); 
+		bd7181x_info(pwr->dev, "BD7181X_REG_CC_BATCAP1_TH = %d\n", (BD7181X_BATTERY_CAP * 9 / 10));
+
+		/* Enable LED ON when charging */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_LED_CTRL, CHGDONE_LED_EN);
+
+		pwr->state_machine = STAT_POWER_ON;
+	} else {
+		pwr->designed_cap = BD7181X_BATTERY_CAP;
+		pwr->full_cap = BD7181X_BATTERY_CAP;	// bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_BATCAP_U);
+		pwr->state_machine = STAT_INITIALIZED;	// STAT_INITIALIZED
+	}
+
+#ifdef CONFIG_LAB126
+	r = bd7181x_reg_read(mfd, BD7181X_REG_BAT_STAT);
+	if (r & BAT_DET){
+		/* Set Battery Capacity Monitor threshold1 as 90% */
+		bd7181x_reg_write16(mfd, BD7181X_REG_CC_BATCAP1_TH_U, (BD7181X_BATTERY_CAP * 9 / 10)); 
+		bd7181x_info(pwr->dev, "BD7181X_REG_CC_BATCAP1_TH = %d\n", (BD7181X_BATTERY_CAP * 9 / 10));
+
+		/* Enable LED ON when charging */
+		bd7181x_set_bits(pwr->mfd, BD7181X_REG_LED_CTRL, CHGDONE_LED_EN);
+	}
+#endif
+
+	pwr->temp = bd7181x_get_temp(pwr);
+	bd7181x_info(pwr->dev, "Temperature = %d\n", pwr->temp);
+	bd7181x_adjust_coulomb_count(pwr);
+	bd7181x_reset_coulomb_count(pwr);
+	pwr->coulomb_cnt = bd7181x_reg_read32(mfd, BD7181X_REG_CC_CCNTD_3) & 0x1FFFFFFFUL;
+	bd7181x_calc_soc_org(pwr);
+	pwr->soc_norm = pwr->soc_org;
+	pwr->soc = pwr->soc_norm;
+	pwr->clamp_soc = pwr->soc;
+	bd7181x_info(pwr->dev, "%s() CC_CCNTD = %d\n", __func__, pwr->coulomb_cnt);
+	bd7181x_info(pwr->dev, "%s() pwr->soc = %d\n", __func__, pwr->soc);
+	bd7181x_info(pwr->dev, "%s() pwr->clamp_soc = %d\n", __func__, pwr->clamp_soc);
+
+	pwr->cycle = battery_cycle;
+	pwr->curr = 0;
+	pwr->curr_sar = 0;
+	pwr->relax_time = 0;
+
+	return 0;
+}
+
+/**@brief timed work function called by system
+ *  read battery capacity,
+ *  sense change of charge status, etc.
+ * @param work work struct
+ * @return  void
+ */
+
+static void bd_work_callback(struct work_struct *work)
+{
+	struct bd7181x_power *pwr;
+	struct delayed_work *delayed_work;
+	int status, changed = 0;
+	static int cap_counter = 0;
+
+	delayed_work = container_of(work, struct delayed_work, work);
+	pwr = container_of(delayed_work, struct bd7181x_power, bd_work);
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_DCIN_STAT);
+	if (status != pwr->vbus_status) {
+		//printk("DCIN_STAT CHANGED from 0x%X to 0x%X\n", pwr->vbus_status, status);
+		pwr->vbus_status = status;
+#ifdef CONFIG_LAB126
+	   if(status != 0) //DCIN connected
+	   {
+		   usbotg_force_bsession(1);
+	   }
+	   else
+	   {
+		   usbotg_force_bsession(0);
+	   }
+#endif
+		changed = 1;
+	}
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+	status &= ~BAT_DET_DONE;
+	if (status != pwr->bat_status) {
+		//printk("BAT_STAT CHANGED from 0x%X to 0x%X\n", pwr->bat_status, status);
+		pwr->bat_status = status;
+		changed = 1;
+	}
+
+	status = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+	if (status != pwr->charge_status) {
+		//printk("CHG_STATE CHANGED from 0x%X to 0x%X\n", pwr->charge_status, status);
+		pwr->charge_status = status;
+		//changed = 1;
+	}
+
+	bd7181x_get_voltage_current(pwr);
+	bd7181x_adjust_coulomb_count(pwr);
+	bd7181x_reset_coulomb_count(pwr);
+	bd7181x_adjust_coulomb_count_sw(pwr);
+	bd7181x_coulomb_count(pwr);
+	bd7181x_update_cycle(pwr);
+	bd7181x_calc_full_cap(pwr);
+	bd7181x_calc_soc_org(pwr);
+	bd7181x_calc_soc_norm(pwr);
+	bd7181x_calc_soc(pwr);
+	bd7181x_calc_soc_clamp(pwr);
+	bd7181x_get_online(pwr);
+	bd7181x_charge_status(pwr);
+
+	if (changed || cap_counter++ > JITTER_REPORT_CAP / JITTER_DEFAULT) {
+		power_supply_changed(&pwr->ac);
+		power_supply_changed(&pwr->bat);
+		cap_counter = 0;
+	}
+
+	if (pwr->calib_current == CALIB_NORM) {
+		schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(JITTER_DEFAULT));
+	} else if (pwr->calib_current == CALIB_START) {
+		pwr->calib_current = CALIB_GO;
+	}
+}
+
+/**@brief bd7181x power interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ */
+static irqreturn_t bd7181x_power_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+
+	printk("bd7181x_power_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_03);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_03 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_03, reg);
+	if (r)
+		return IRQ_NONE;
+
+	if (reg & DCIN_MON_DET) {
+		printk("\n~~~DCIN removed\n");
+	} else if (reg & DCIN_MON_RES) {
+		printk("\n~~~DCIN inserted\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**@brief bd7181x vbat low voltage detection interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ * added by John Zhang at 2015-07-22
+ */
+static irqreturn_t bd7181x_vbat_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+
+	printk("bd7181x_vbat_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_08);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_08 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_08, reg);
+	if (r)
+		return IRQ_NONE;
+
+	if (reg & VBAT_MON_DET) {
+		printk("\n~~~ VBAT LOW Detected ... \n");
+		
+	} else if (reg & VBAT_MON_RES) {
+		printk("\n~~~ VBAT LOW Resumed ... \n");
+	}
+
+	return IRQ_HANDLED;
+	
+}
+
+/**@brief bd7181x int_stat_11 detection interrupt
+ * @param irq system irq
+ * @param pwrsys bd7181x power device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ * added 2015-12-26
+ */
+static irqreturn_t bd7181x_int_11_interrupt(int irq, void *pwrsys)
+{
+	struct device *dev = pwrsys;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	// struct bd7181x_power *pwr = dev_get_drvdata(dev);
+	int reg, r;
+	
+	printk("bd7181x_int_11_interrupt() in.\n");
+	
+	reg = bd7181x_reg_read(mfd, BD7181X_REG_INT_STAT_11);
+	if (reg < 0)
+		return IRQ_NONE;
+
+	printk("INT_STAT_11 = 0x%.2X\n", reg);
+
+	r = bd7181x_reg_write(mfd, BD7181X_REG_INT_STAT_11, reg);
+	if (r) {
+		return IRQ_NONE;
+	}
+
+	if (reg & INT_STAT_11_VF_DET) {
+		printk("\n~~~ VF Detected ... \n");
+	} else if (reg & INT_STAT_11_VF_RES) {
+		printk("\n~~~ VF Resumed ... \n");
+	} else if (reg & INT_STAT_11_VF125_DET) {
+		printk("\n~~~ VF125 Detected ... \n");
+	} else if (reg & INT_STAT_11_VF125_RES) {
+		printk("\n~~~ VF125 Resumed ... \n");
+	} else if (reg & INT_STAT_11_OVTMP_DET) {
+		printk("\n~~~ Overtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_OVTMP_RES) {
+		printk("\n~~~ Overtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_LOTMP_DET) {
+		printk("\n~~~ Lowtemp Detected ... \n");
+	} else if (reg & INT_STAT_11_LOTMP_RES) {
+		printk("\n~~~ Lowtemp Detected ... \n");
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+/** @brief get property of power supply ac
+ *  @param psy power supply deivce
+ *  @param psp property to get
+ *  @param val property value to return
+ *  @retval 0  success
+ *  @retval negative fail
+ */
+static int bd7181x_charger_get_property(struct power_supply *psy,
+					enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bd7181x_power *pwr = dev_get_drvdata(psy->dev->parent);
+	u32 vot;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = pwr->charger_online;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		vot = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_VM_DCIN_U);
+		val->intval = 5000 * vot;		// 5 milli volt steps
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/** @brief get property of power supply bat
+ *  @param psy power supply deivce
+ *  @param psp property to get
+ *  @param val property value to return
+ *  @retval 0  success
+ *  @retval negative fail
+ */
+
+static int bd7181x_battery_get_property(struct power_supply *psy,
+					enum power_supply_property psp, union power_supply_propval *val)
+{
+	struct bd7181x_power *pwr = dev_get_drvdata(psy->dev->parent);
+	// u32 cap, vot, r;
+	// u8 ret;
+
+	switch (psp) {
+	/*
+	case POWER_SUPPLY_PROP_STATUS:
+		r = bd7181x_reg_read(pwr->mfd, BD7181X_REG_CHG_STATE);
+		// printk("CHG_STATE = 0x%.2X\n", r);
+		switch(r) {
+		case CHG_STATE_SUSPEND:
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		case CHG_STATE_TRICKLE_CHARGE:
+		case CHG_STATE_PRE_CHARGE:
+		case CHG_STATE_FAST_CHARGE:
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			break;
+		case CHG_STATE_TOP_OFF:
+		case CHG_STATE_DONE:
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+			break;
+		default:
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		ret = bd7181x_reg_read(pwr->mfd, BD7181X_REG_BAT_STAT);
+		if (ret & DBAT_DET)
+			val->intval = POWER_SUPPLY_HEALTH_DEAD;
+		else if (ret & VBAT_OV)
+			val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+		else
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		cap = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_CC_BATCAP_U);
+		// printk("CC_BATCAP = 0x%.4X\n", cap);
+		val->intval = cap * 100 / 0x1FFF;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		vot = bd7181x_reg_read16(pwr->mfd, BD7181X_REG_VM_VBAT_U) * 1000;
+		val->intval = vot;
+		break;
+	*/
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = pwr->rpt_status;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = pwr->bat_health;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		if (pwr->rpt_status == POWER_SUPPLY_STATUS_CHARGING)
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		else
+			val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = pwr->bat_online;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = pwr->vcell;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = pwr->clamp_soc;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		{
+		u32 t;
+
+		t = pwr->coulomb_cnt >> 16;
+		t = A10s_mAh(t);
+		if (t > A10s_mAh(pwr->designed_cap)) t = A10s_mAh(pwr->designed_cap);
+		val->intval = t * 1000;		/* uA to report */
+		}
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = pwr->bat_online;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = BD7181X_BATTERY_FULL * A10s_mAh(pwr->designed_cap) * 10;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = BD7181X_BATTERY_FULL * A10s_mAh(pwr->full_cap) * 10;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = pwr->curr_sar;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		val->intval = pwr->curr;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = pwr->temp * 10; /* 0.1 degrees C unit */
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = MAX_VOLTAGE;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN:
+		val->intval = MIN_VOLTAGE;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = MAX_CURRENT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/** @brief ac properties */
+static enum power_supply_property bd7181x_charger_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+/** @brief bat properies */
+static enum power_supply_property bd7181x_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+/** @brief directly set raw value to chip register, format: 'register value' */
+static ssize_t bd7181x_sysfs_set_registers(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	unsigned int reg;
+	unsigned int val;
+
+	ret = sscanf(buf, "%x %x", &reg, &val);
+	if (ret < 1) {
+		pwr->reg_index = -1;
+		return count;
+	}
+
+	if (ret == 1 && reg <= BD7181X_MAX_REGISTER) {
+		pwr->reg_index = reg;
+		return count;
+	}
+	if (reg > BD7181X_MAX_REGISTER || val > 255)
+		return -EINVAL;
+
+	ret = bd7181x_reg_write(pwr->mfd, reg, val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+/** @brief print value of chip register, format: 'register=value' */
+static ssize_t bd7181x_sysfs_print_reg(struct bd7181x_power *pwr,
+				       u8 reg,
+				       char *buf)
+{
+	int ret = bd7181x_reg_read(pwr->mfd, reg);
+
+	if (ret < 0)
+		return sprintf(buf, "%#.2x=error %d\n", reg, ret);
+	return sprintf(buf, "[0x%.2X] = %.2X\n", reg, ret);
+}
+
+/** @brief show all raw values of chip register, format per line: 'register=value' */
+static ssize_t bd7181x_sysfs_show_registers(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	int i;
+
+	if (pwr->reg_index >= 0) {
+		ret += bd7181x_sysfs_print_reg(pwr, pwr->reg_index, buf + ret);
+	} else {
+		for (i = 0; i <= BD7181X_MAX_REGISTER; i++) {
+			ret += bd7181x_sysfs_print_reg(pwr, i, buf + ret);
+		}
+	}
+	return ret;
+}
+
+static DEVICE_ATTR(registers, S_IWUSR | S_IRUGO,
+		bd7181x_sysfs_show_registers, bd7181x_sysfs_set_registers);
+
+static int first_offset(struct bd7181x_power *pwr)
+{
+	unsigned char ra2, ra3, ra6, ra7;
+	unsigned char ra2_temp;
+	struct bd7181x *mfd = pwr->mfd;
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+
+
+	ra2 = bd7181x_reg_read(mfd, 0xA2);	// I want to know initial A2 & A3.
+	ra3 = bd7181x_reg_read(mfd, 0xA3);	// I want to know initial A2 & A3.
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+
+	bd7181x_reg_write(mfd, 0xA2, 0x00);
+	bd7181x_reg_write(mfd, 0xA3, 0x00);
+
+	bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2);
+	bd7181x_info(pwr->dev, "TEST[A3] = 0x%.2X\n", ra3);
+	bd7181x_info(pwr->dev, "TEST[A6] = 0x%.2X\n", ra6);
+	bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+
+	//-------------- First Step -------------------
+	bd7181x_info(pwr->dev, "Frist Step begginning \n");
+
+	// delay some time , Make a state of IBAT=0mA
+	// mdelay(1000 * 10);
+
+	ra2_temp = ra2;
+
+	if (ra7 != 0) {
+		//if 0<0xA7<20 decrease the Test register 0xA2[7:3] until 0xA7 becomes 0x00.
+		if ((ra7 > 0) && (ra7 < 20)) {
+			do {
+				ra2 = bd7181x_reg_read(mfd, 0xA2);
+				ra2_temp = ra2 >> 3;
+				ra2_temp -= 1;
+				ra2_temp <<= 3;
+				bd7181x_reg_write(mfd, 0xA2, ra2_temp);
+				bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2_temp);
+
+				ra7 = bd7181x_reg_read(mfd, 0xA7);
+				bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+				mdelay(1000);	// 1sec?
+			} while (ra7);
+
+			bd7181x_info(pwr->dev, "A7 becomes 0 . \n");
+
+		}		// end if((ra7 > 0)&&(ra7 < 20)) 
+		else if ((ra7 > 0xDF) && (ra7 < 0xFF))
+			//if DF<0xA7<FF increase the Test register 0xA2[7:3] until 0xA7 becomes 0x00.
+		{
+			do {
+				ra2 = bd7181x_reg_read(mfd, 0xA2);
+				ra2_temp = ra2 >> 3;
+				ra2_temp += 1;
+				ra2_temp <<= 3;
+
+				bd7181x_reg_write(mfd, 0xA2, ra2_temp);
+				bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X\n", ra2_temp);
+
+				ra7 = bd7181x_reg_read(mfd, 0xA7);
+				bd7181x_info(pwr->dev, "TEST[A7] = 0x%.2X\n", ra7);
+				mdelay(1000);	// 1sec?                           
+			} while (ra7);
+
+			bd7181x_info(pwr->dev, "A7 becomes 0 . \n");
+		}
+	}
+
+	// please use "ra2_temp" at step2.
+	return ra2_temp;
+}
+
+static int second_step(struct bd7181x_power *pwr, u8 ra2_temp)
+{
+	u16 ra6, ra7;
+	u8 aft_ra2, aft_ra3;
+	u8 r79, r7a;
+	unsigned int LNRDSA_FUSE;
+	long ADC_SIGN;
+	long DSADGAIN1_INI;
+	struct bd7181x *mfd = pwr->mfd;
+
+	//-------------- Second Step -------------------
+	bd7181x_info(pwr->dev, "Second Step begginning \n");
+
+	// need to change boad setting ( input 1A tio 10mohm)
+	// delay some time , Make a state of IBAT=1000mA
+	// mdelay(1000 * 10);
+
+// rough adjust
+	bd7181x_info(pwr->dev, "ra2_temp = 0x%.2X\n", ra2_temp);
+
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+	ra6 <<= 8;
+	ra6 |= ra7;		// [0xA6 0xA7]
+	bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+	bd7181x_reg_write(mfd, 0xA2, ra2_temp);	// this value from step1
+	bd7181x_reg_write(mfd, 0xA3, 0x00);
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+
+	r79 = bd7181x_reg_read(mfd, 0x79);
+	r7a = bd7181x_reg_read(mfd, 0x7A);
+
+	ADC_SIGN = r79 >> 7;
+	ADC_SIGN = 1 - (2 * ADC_SIGN);
+	DSADGAIN1_INI = r79 << 8;
+	DSADGAIN1_INI = DSADGAIN1_INI + r7a;
+	DSADGAIN1_INI = DSADGAIN1_INI & 0x7FFF;
+	DSADGAIN1_INI = DSADGAIN1_INI * ADC_SIGN; //  unit 0.001
+
+	// unit 0.000001
+	DSADGAIN1_INI *= 1000;
+	{
+	if (DSADGAIN1_INI > 1000001) {
+		DSADGAIN1_INI = 2048000000UL - (DSADGAIN1_INI - 1000000) * 8187;
+	} else if (DSADGAIN1_INI < 999999) {
+		DSADGAIN1_INI = -(DSADGAIN1_INI - 1000000) * 8187;
+	} else {
+		DSADGAIN1_INI = 0;
+	}
+	}
+
+	LNRDSA_FUSE = (int) DSADGAIN1_INI / 1000000;
+
+	bd7181x_info(pwr->dev, "LNRDSA_FUSE = 0x%.8X\n", LNRDSA_FUSE);
+
+	aft_ra2 = (LNRDSA_FUSE >> 8) & 255;
+	aft_ra3 = (LNRDSA_FUSE) & 255;
+
+	aft_ra2 = aft_ra2 + ra2_temp;
+
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_01);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_02);
+	bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_03);
+
+	bd7181x_reg_write(mfd, 0xA2, aft_ra2);
+	bd7181x_reg_write(mfd, 0xA3, aft_ra3);
+
+	return 0;
+}
+
+static int third_step(struct bd7181x_power *pwr, unsigned thr) {
+	u16 ra2_a3, ra6, ra7;
+	u8 ra2, ra3;
+	u8 aft_ra2, aft_ra3;
+	struct bd7181x *mfd = pwr->mfd;
+
+// fine adjust
+	ra2 = bd7181x_reg_read(mfd, 0xA2);	//
+	ra3 = bd7181x_reg_read(mfd, 0xA3);	//
+
+	ra6 = bd7181x_reg_read(mfd, 0xA6);
+	ra7 = bd7181x_reg_read(mfd, 0xA7);
+	ra6 <<= 8;
+	ra6 |= ra7;		// [0xA6 0xA7]
+	bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+
+	if (ra6 > thr) {
+		do {
+			ra2_a3 = bd7181x_reg_read(mfd, 0xA2);
+			ra2_a3 <<= 8;
+			ra3 = bd7181x_reg_read(mfd, 0xA3);
+			ra2_a3 |= ra3;
+			//ra2_a3 >>= 3; // ? 0xA3[7:3] , or 0xA3[7:0]
+
+			ra2_a3 -= 1;
+			//ra2_a3 <<= 3;
+			ra3 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA3, ra3);
+
+			ra2_a3 >>= 8;
+			ra2 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA2, ra2);
+
+			bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X , TEST[A3] = 0x%.2X \n", ra2, ra3);
+
+			mdelay(1000);	// 1sec?
+
+			ra6 = bd7181x_reg_read(mfd, 0xA6);
+			ra7 = bd7181x_reg_read(mfd, 0xA7);
+			ra6 <<= 8;
+			ra6 |= ra7;	// [0xA6 0xA7]
+			bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+		} while (ra6 > thr);
+	} else if (ra6 < thr) {
+		do {
+			ra2_a3 = bd7181x_reg_read(mfd, 0xA2);
+			ra2_a3 <<= 8;
+			ra3 = bd7181x_reg_read(mfd, 0xA3);
+			ra2_a3 |= ra3;
+			//ra2_a3 >>= 3; // ? 0xA3[7:3] , or 0xA3[7:0]
+
+			ra2_a3 += 1;
+			//ra2_a3 <<= 3;
+			ra3 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA3, ra3);
+
+			ra2_a3 >>= 8;
+			ra2 = ra2_a3;
+			bd7181x_reg_write(mfd, 0xA2, ra2);
+
+			bd7181x_info(pwr->dev, "TEST[A2] = 0x%.2X , TEST[A3] = 0x%.2X \n", ra2, ra3);
+
+			mdelay(1000);	// 1sec?
+
+			ra6 = bd7181x_reg_read(mfd, 0xA6);
+			ra7 = bd7181x_reg_read(mfd, 0xA7);
+			ra6 <<= 8;
+			ra6 |= ra7;	// [0xA6 0xA7]
+			bd7181x_info(pwr->dev, "TEST[A6,A7] = 0x%.4X\n", ra6);
+
+		} while (ra6 < thr);
+	}
+
+	bd7181x_info(pwr->dev, "[0xA6 0xA7] becomes [0x%.4X] . \n", thr);
+	bd7181x_info(pwr->dev, " Calibation finished ... \n\n");
+
+	aft_ra2 = bd7181x_reg_read(mfd, 0xA2);	// 
+	aft_ra3 = bd7181x_reg_read(mfd, 0xA3);	// I want to know initial A2 & A3.
+
+	bd7181x_info(pwr->dev, "TEST[A2,A3] = 0x%.2X%.2X\n", aft_ra2, aft_ra3);
+
+	// bd7181x_reg_write(mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+
+	return 0;
+}
+
+static ssize_t bd7181x_sysfs_set_calibrate(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+	unsigned int val, mA;
+	static u8 rA2;
+
+	ret = sscanf(buf, "%d %d", &val, &mA);
+	if (ret < 1) {
+		bd7181x_info(pwr->dev, "error: write a integer string");
+		return count;
+	}
+
+	if (val == 1) {
+		pwr->calib_current = CALIB_START;
+		while (pwr->calib_current != CALIB_GO) {
+			msleep(500);
+		}
+		rA2 = first_offset(pwr);
+	}
+	if (val == 2) {
+		second_step(pwr, rA2);
+	}
+	if (val == 3) {
+		if (ret <= 1) {
+			bd7181x_info(pwr->dev, "error: Fine adjust need a mA argument!");
+		} else {
+		unsigned int ra6_thr;
+
+		ra6_thr = mA * 0xFFFF / 20000;
+		bd7181x_info(pwr->dev, "Fine adjust at %d mA, ra6 threshold %d(0x%X)\n", mA, ra6_thr, ra6_thr);
+		third_step(pwr, ra6_thr);
+		}
+	}
+	if (val == 4) {
+		bd7181x_reg_write(pwr->mfd, BD7181X_REG_TEST_MODE, TEST_SEQ_00);
+		pwr->calib_current = CALIB_NORM;
+		schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(0));
+	}
+
+	return count;
+}
+
+static ssize_t bd7181x_sysfs_show_calibrate(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	// struct power_supply *psy = dev_get_drvdata(dev);
+	// struct bd7181x_power *pwr = container_of(psy, struct bd7181x_power, bat);
+	ssize_t ret = 0;
+
+	ret = 0;
+	ret += sprintf(buf + ret, "write string value\n"
+		"\t1      0 mA for step one\n"
+		"\t2      1000 mA for rough adjust\n"
+		"\t3 <mA> for fine adjust\n"
+		"\t4      exit current calibration\n");
+	return ret;
+}
+
+static DEVICE_ATTR(calibrate, S_IWUSR | S_IRUGO,
+		bd7181x_sysfs_show_calibrate, bd7181x_sysfs_set_calibrate);
+
+static struct attribute *bd7181x_sysfs_attributes[] = {
+	/*
+	 * TODO: some (appropriate) of these attrs should be switched to
+	 * use pwr supply class props.
+	 */
+	&dev_attr_registers.attr,
+	&dev_attr_calibrate.attr,
+	NULL,
+};
+
+static const struct attribute_group bd7181x_sysfs_attr_group = {
+	.attrs = bd7181x_sysfs_attributes,
+};
+
+/** @brief powers supplied by bd7181x_ac */
+static char *bd7181x_ac_supplied_to[] = {
+	BAT_NAME,
+};
+
+/** @brief probe pwr device 
+ * @param pdev platform deivce of bd7181x_power
+ * @retval 0 success
+ * @retval negative fail
+ */
+static int __init bd7181x_power_probe(struct platform_device *pdev)
+{
+	struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct bd7181x_power *pwr;
+	int irq, ret, reg;
+
+	pwr = kzalloc(sizeof(*pwr), GFP_KERNEL);
+	if (pwr == NULL)
+		return -ENOMEM;
+
+	pwr->dev = &pdev->dev;
+	pwr->mfd = bd7181x;
+
+	platform_set_drvdata(pdev, pwr);
+
+	if (battery_cycle <= 0) {
+		battery_cycle = 0;
+	}
+	dev_err(pwr->dev, "battery_cycle = %d\n", battery_cycle);
+
+	/* If the product often power up/down and the power down time is long, the Coulomb Counter may have a drift. */
+	/* If so, it may be better accuracy to enable Coulomb Counter using following commented out code */
+	/* for counting Coulomb when the product is power up(including sleep). */
+	/* The condition  */
+	/* (1) Product often power up and down, the power down time is long and there is no power consumed in power down time. */
+	/* (2) Kernel must call this routin at power up time. */
+	/* (3) Kernel must call this routin at charging time. */
+	/* (4) Must use this code with "Stop Coulomb Counter" code in bd7181x_power_remove() function */
+	/* Start Coulomb Counter */
+	/* bd7181x_set_bits(pwr->mfd, BD7181x_REG_CC_CTRL, CCNTENB); */
+
+	bd7181x_init_hardware(pwr);
+
+	pwr->bat.name = BAT_NAME;
+	pwr->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	pwr->bat.properties = bd7181x_battery_props;
+	pwr->bat.num_properties = ARRAY_SIZE(bd7181x_battery_props);
+	pwr->bat.get_property = bd7181x_battery_get_property;
+
+	ret = power_supply_register(&pdev->dev, &pwr->bat);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
+		goto fail_register_bat;
+	}
+
+	pwr->ac.name = AC_NAME;
+	pwr->ac.type = POWER_SUPPLY_TYPE_MAINS;
+	pwr->ac.properties = bd7181x_charger_props;
+	pwr->ac.supplied_to = bd7181x_ac_supplied_to;
+	pwr->ac.num_supplicants = ARRAY_SIZE(bd7181x_ac_supplied_to);
+	pwr->ac.num_properties = ARRAY_SIZE(bd7181x_charger_props);
+	pwr->ac.get_property = bd7181x_charger_get_property;
+
+	ret = power_supply_register(&pdev->dev, &pwr->ac);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register ac: %d\n", ret);
+		goto fail_register_ac;
+	}
+
+	/*Add DC_IN Inserted and Remove ISR */
+	irq  = platform_get_irq(pdev, 0); // get irq number 
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_power_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/*add VBAT Low Voltage detection, John Zhang*/
+	irq  = platform_get_irq(pdev, 1);
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_vbat_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/* add INT_STAT_11 */
+	irq  = platform_get_irq(pdev, 2);
+#ifdef __BD7181X_REGMAP_H__
+	irq += bd7181x->irq_base;
+#endif
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "platform irq error # %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_int_11_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ %d is not free.\n", irq);
+	}
+
+	/* Enable INT_11 */
+	ret = bd7181x_reg_write(bd7181x, BD7181X_REG_INT_EN_11, 0xFF);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "Write BD7181X_REG_INT_EN_11 failed\n");
+	}
+	reg = bd7181x_reg_read(bd7181x, BD7181X_REG_INT_EN_11);
+	if (reg < 0) {
+		dev_warn(&pdev->dev, "Read BD7181X_REG_INT_EN_11 failed\n");
+	}
+	dev_info(&pdev->dev, "BD7181X_REG_INT_EN_11=0x%x\n", reg);
+
+
+	ret = sysfs_create_group(&pwr->bat.dev->kobj, &bd7181x_sysfs_attr_group);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register sysfs interface\n");
+	}
+
+	pwr->reg_index = -1;
+
+	INIT_DELAYED_WORK(&pwr->bd_work, bd_work_callback);
+
+	/* Schedule timer to check current status */
+	pwr->calib_current = CALIB_NORM;
+	schedule_delayed_work(&pwr->bd_work, msecs_to_jiffies(0));
+
+	return 0;
+
+//error_exit:
+	power_supply_unregister(&pwr->ac);
+fail_register_ac:
+	power_supply_unregister(&pwr->bat);
+fail_register_bat:
+	platform_set_drvdata(pdev, NULL);
+	kfree(pwr);
+
+	return ret;
+}
+
+/** @brief remove pwr device
+ * @param pdev platform deivce of bd7181x_power
+ * @return 0
+ */
+
+static int __exit bd7181x_power_remove(struct platform_device *pdev)
+{
+	struct bd7181x_power *pwr = platform_get_drvdata(pdev);
+
+	/* If the product often power up/down and the power down time is long, the Coulomb Counter may have a drift. */
+	/* If so, it may be better accuracy to disable Coulomb Counter using following commented out code */
+	/* for stopping counting Coulomb when the product is power down(without sleep). */
+	/* The condition  */
+	/* (1) Product often power up and down, the power down time is long and there is no power consumed in power down time. */
+	/* (2) Kernel must call this routin at power down time. */
+	/* (3) Must use this code with "Start Coulomb Counter" code in bd7181x_power_probe() function */
+	/* Stop Coulomb Counter */
+	/* bd7181x_clear_bits(pwr->mfd, BD7181x_REG_CC_CTRL, CCNTENB); */
+
+	sysfs_remove_group(&pwr->bat.dev->kobj, &bd7181x_sysfs_attr_group);
+
+	cancel_delayed_work(&pwr->bd_work);
+
+	power_supply_unregister(&pwr->bat);
+	power_supply_unregister(&pwr->ac);
+	platform_set_drvdata(pdev, NULL);
+	kfree(pwr);
+
+	return 0;
+}
+
+static struct platform_driver bd7181x_power_driver = {
+	.driver = {
+		.name = "bd7181x-power",
+		.owner = THIS_MODULE,
+	},
+	.remove = __exit_p(bd7181x_power_remove),
+};
+
+/** @brief module initialize function */
+static int __init bd7181x_power_init(void)
+{
+	return platform_driver_probe(&bd7181x_power_driver, bd7181x_power_probe);
+}
+
+module_init(bd7181x_power_init);
+
+/** @brief module deinitialize function */
+static void __exit bd7181x_power_exit(void)
+{
+	platform_driver_unregister(&bd7181x_power_driver);
+}
+
+module_exit(bd7181x_power_exit);
+
+module_param(battery_cycle, uint, S_IWUSR | S_IRUGO);
+MODULE_PARM_DESC(battery_parameters, "battery_cycle:battery charge/discharge cycles");
+
+MODULE_AUTHOR("Tony Luo <luofc@embest-tech.com>");
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 Battery Charger Power driver");
+MODULE_LICENSE("GPL");
+
+
+/*-------------------------------------------------------*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#define PROCFS_NAME 		"bd7181x_rev"
+#if defined(BD7181X_REV_LONG)
+#define BD7181X_REV			"BD7181x Driver: \n" \
+							"1.Rev1583/rev1584: \n" \
+							"  Reason of change: \n" \
+							"  \tDVDREF LDO is not staying ON.\n" \
+							"  Changes: \n" \
+							"  \tThis LDO is disabled in the .dts file. \n" \
+							"  \tWe are now keeping this LDO always ON.\n" \
+							"2.Rev1585: \n" \
+							"  Reason of change: \n" \
+							"  \tBugs found during testing.\n" \
+							"  Changes: \n" \
+							"  \tTemp measurment in init function SOC when very low gives wrong value.\n" \
+							"  \tChanges done by Lab incoroprated with Rohm.\n" \
+							"3.Rev1586: \n" \
+							"  Reason of change: \n" \
+							"  \tLab production testing of green led's and \n" \
+							"  \tship mode requires some initilzation of  \n" \
+							"  \tregisters during driver boot up.\n" \
+							"  Changes: \n" \
+							"  \tRegisters are being set in the probe/init function as requesed by lab.\n" \
+							"4.Rev1587: \n" \
+							"  Reason of change: \n" \
+							"  \tRead changes history.\n" \
+							"  Changes: \n" \
+							"  \tAdd module comand '/proc/bd7181x_rev'.\n" \
+							"  \tInstruction: 'cat /proc/bd7181x_rev' \n"
+							"5.Rev1588: \n" \
+							"  Reason of change: \n" \
+							"  \tImplement Interrupt to process VF/VF125/OVTMP/LOTMP Detect/Resume.\n" \
+							"  Changes: \n" \
+							"  \tAdd interrupt resource 'power_resources[2]' at 'bd7181x.c'.\n" \
+							"  \tAdd interrupt handler function 'bd7181x_int_11_interrupt()' at 'bd7181x-power.c'\n"
+#else
+#define BD7181X_REV			"BD7181x Driver: Rev1589\n"
+#endif
+
+#define BD7181X_BUF_SIZE	1024
+static char procfs_buffer[BD7181X_BUF_SIZE];
+/**
+ * This function is called then the /proc file is read
+ *
+ */
+static int onetime = 0;
+static ssize_t bd7181x_proc_read (struct file *file, char __user *buffer, size_t count, loff_t *data)
+{
+	int ret = 0, error = 0;
+	if(onetime==0) {
+		onetime = 1;
+		memset( procfs_buffer, 0, BD7181X_BUF_SIZE);
+		sprintf(procfs_buffer, "%s", BD7181X_REV);
+		ret = strlen(procfs_buffer);
+		error = copy_to_user(buffer, procfs_buffer, strlen(procfs_buffer));
+	} else {
+		//Clear for next time
+		onetime = 0;
+	}
+	return (error!=0)?0:ret;
+}
+
+static const struct file_operations bd7181x_proc_fops = {
+	.owner		= THIS_MODULE,
+	.read		= bd7181x_proc_read,
+};
+
+/**
+ *This function is called when the module is loaded
+ *
+ */
+int bd7181x_revision_init(void)
+{
+	struct proc_dir_entry *bd7181x_proc_entry;
+
+	/* create the /proc/bd7181x_rev */
+	bd7181x_proc_entry = proc_create(PROCFS_NAME, 0644, NULL, &bd7181x_proc_fops);
+	if (bd7181x_proc_entry == NULL) {
+		printk("Error: Could not initialize /proc/%s\n", PROCFS_NAME);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+module_init(bd7181x_revision_init);
+/*-------------------------------------------------------*/
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index ed96adc..ad12a7a 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -596,5 +596,12 @@ config REGULATOR_WM8994
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
+
+config REGULATOR_BD7181X
+    tristate "RoHM BD71815/BD71817 Power Regulator"
+    depends on MFD_BD7181X
+    help
+      This driver supports BD71815/BD71817 voltage regulator chips.
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index a2163ca..5ae2f74 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -81,6 +81,6 @@ obj-$(CONFIG_REGULATOR_WM831X) += wm831x-ldo.o
 obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
-
+obj-$(CONFIG_REGULATOR_BD7181X) += bd7181x-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/bd7181x-regulator.c b/drivers/regulator/bd7181x-regulator.c
new file mode 100644
index 0000000..cb0f924
--- /dev/null
+++ b/drivers/regulator/bd7181x-regulator.c
@@ -0,0 +1,551 @@
+/*
+ * @file bd7181x-regulator.c RoHM BD71815/BD71817 regulator driver
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * @author Tony Luo <luofc@embedinfo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/mfd/bd7181x.h>
+#include <linux/regulator/of_regulator.h>
+
+#define BD7181X_VOL_OFFSET		0
+#define BD7181X_STANDBY_OFFSET		0
+
+struct bd7181x_regulator {
+	struct regulator_desc desc;
+	unsigned char stby_reg;
+	unsigned char stby_mask;
+};
+
+/** @brief bd7181x regulator type */
+struct bd7181x_pmic {
+	struct bd7181x_regulator descs[BD7181X_REGULATOR_CNT];	/**< regulator description to system */
+	struct bd7181x *mfd;					/**< parent device */
+	struct device *dev;					/**< regulator kernel device */
+	struct regulator_dev *rdev[BD7181X_REGULATOR_CNT];	/**< regulator device of system */
+};
+
+static const int bd7181x_wled_currents[] = {
+	// 0x00
+	10, 20, 30, 50,
+	70, 100, 200, 300,
+	500, 700, 1000, 2000,
+	3000, 4000, 5000, 6000,
+	// 0x10
+	7000, 8000, 9000, 10000,
+	11000, 12000, 13000, 14000,
+	15000, 16000, 17000, 18000,
+	19000, 20000, 21000, 22000,
+	// 0x20
+	23000, 24000, 25000,
+};
+
+static int bd7181x_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay) {
+	struct bd7181x_pmic *pmic = rdev_get_drvdata(rdev);
+	struct bd7181x *mfd = pmic->mfd;
+	// int id = rdev->desc->id;
+	unsigned int ramp_bits;
+	int ret;
+
+	if (1 /*TODO*/ ) {
+		ramp_delay = 12500 / ramp_delay;
+		ramp_bits = (ramp_delay >> 1) - (ramp_delay >> 3);
+		ret = regmap_update_bits(mfd->regmap,
+					 rdev->desc->vsel_reg + 4,
+					 0xc0, ramp_bits << 6);
+		if (ret < 0)
+			dev_err(pmic->dev, "ramp failed, err %d\n", ret);
+	} else
+		ret = -EACCES;
+
+	return ret;
+}
+
+static int bd7181x_led_set_current_limit(struct regulator_dev *rdev,
+					int min_uA, int max_uA)
+{
+	struct bd7181x_pmic* pmic = rdev_get_drvdata(rdev);
+	struct bd7181x* mfd = pmic->mfd;
+	u8 addr;
+	// int id = rdev_get_id(rdev);
+	int i;
+
+	addr = BD7181X_REG_LED_DIMM;
+
+	for (i = ARRAY_SIZE(bd7181x_wled_currents) - 1 ; i >= 0; i--) {
+		if (bd7181x_wled_currents[i] >= min_uA &&
+			bd7181x_wled_currents[i] <= max_uA)
+			return bd7181x_update_bits(mfd, addr, 0x3F, i);
+	}
+
+	return -EINVAL;
+}
+
+static int bd7181x_led_get_current_limit(struct regulator_dev *rdev)
+{
+	struct bd7181x_pmic* pmic = rdev_get_drvdata(rdev);
+	struct bd7181x* mfd = pmic->mfd;
+	// int id = rdev_get_id(rdev);
+	u8 addr;
+	int r;
+
+	addr = BD7181X_REG_LED_DIMM;
+
+	r = bd7181x_reg_read(mfd, addr);
+	if (r < 0) {
+		return r;
+	}
+
+	r = r & 0x3F;
+
+	return (r < ARRAY_SIZE(bd7181x_wled_currents)) ?
+			bd7181x_wled_currents[r] : -EINVAL;
+}
+
+static struct regulator_ops bd7181x_ldo_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+};
+
+static struct regulator_ops bd7181x_fixed_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+};
+
+static struct regulator_ops bd7181x_buck_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_time_sel = regulator_set_voltage_time_sel,
+	.set_ramp_delay = bd7181x_set_ramp_delay,
+};
+
+static struct regulator_ops bd7181x_led_regulator_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_table,
+	.map_voltage = regulator_map_voltage_ascend,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_current_limit = bd7181x_led_set_current_limit,
+	.get_current_limit = bd7181x_led_get_current_limit,
+};
+
+#define BD7181X_FIXED_REG(_name, ereg, emsk, voltage)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = 1,	\
+			.ops = &bd7181x_fixed_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (voltage),	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+	}
+
+#define BD7181X_BUCK_REG(_name, base, ereg, min, max, step)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,\
+			.n_voltages = ((max) - (min)) / (step) + 1,	\
+			.ops = &bd7181x_buck_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (min),	\
+			.uV_step = (step),	\
+			.vsel_reg = (base) + BD7181X_VOL_OFFSET,	\
+			.vsel_mask = 0x3f,	\
+			.enable_reg = (ereg),	\
+			.enable_mask = 0x04,	\
+		},	\
+		.stby_reg = (base) + BD7181X_STANDBY_OFFSET,	\
+		.stby_mask = 0x3f,	\
+	}
+
+#define BD7181X_LED_REG(_name, base, mask, ereg, emsk, voltages)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = ARRAY_SIZE(voltages),	\
+			.ops = &bd7181x_led_regulator_ops,	\
+			.type = REGULATOR_CURRENT,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.volt_table = voltages,	\
+			.vsel_reg = (base),	\
+			.vsel_mask = (mask),	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+	}
+
+#define BD7181X_LDO_REG(_name, base, ereg, emsk, min, max, step)	\
+	[BD7181X_ ## _name] = {	\
+		.desc = {	\
+			.name = #_name,	\
+			.n_voltages = ((max) - (min)) / (step) + 1,	\
+			.ops = &bd7181x_ldo_regulator_ops,	\
+			.type = REGULATOR_VOLTAGE,	\
+			.id = BD7181X_ ## _name,	\
+			.owner = THIS_MODULE,	\
+			.min_uV = (min),	\
+			.uV_step = (step),	\
+			.vsel_reg = (base),	\
+			.vsel_mask = 0x3f,	\
+			.enable_reg = (ereg),	\
+			.enable_mask = (emsk),	\
+		},	\
+		.stby_reg = (base),	\
+		.stby_mask = 0x20,	\
+	}
+
+static struct bd7181x_regulator bd7181x_regulators[] = {
+	BD7181X_BUCK_REG(BUCK1, BD7181X_REG_BUCK1_VOLT_H, BD7181X_REG_BUCK1_MODE, 800000, 2000000, 25000),
+	BD7181X_BUCK_REG(BUCK2, BD7181X_REG_BUCK2_VOLT_H, BD7181X_REG_BUCK2_MODE, 800000, 2000000, 25000),
+	BD7181X_BUCK_REG(BUCK3, BD7181X_REG_BUCK3_VOLT, BD7181X_REG_BUCK3_MODE,  1200000, 2700000, 50000),
+	BD7181X_BUCK_REG(BUCK4, BD7181X_REG_BUCK4_VOLT, BD7181X_REG_BUCK4_MODE,  1100000, 1850000, 25000),
+	BD7181X_BUCK_REG(BUCK5, BD7181X_REG_BUCK5_VOLT, BD7181X_REG_BUCK5_MODE,  1800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO1, BD7181X_REG_LDO1_VOLT, BD7181X_REG_LDO_MODE1, 0x40, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO2, BD7181X_REG_LDO2_VOLT, BD7181X_REG_LDO_MODE2, 0x04, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO3, BD7181X_REG_LDO3_VOLT, BD7181X_REG_LDO_MODE2, 0x40, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO4, BD7181X_REG_LDO4_VOLT, BD7181X_REG_LDO_MODE3, 0x04, 800000, 3300000, 50000),
+	BD7181X_LDO_REG(LDO5, BD7181X_REG_LDO5_VOLT_H,BD7181X_REG_LDO_MODE3,0x40, 800000, 3300000, 50000),
+	BD7181X_FIXED_REG(LDODVREF, BD7181X_REG_LDO_MODE4, 0x40, 3000000),
+	BD7181X_FIXED_REG(LDOLPSR, BD7181X_REG_LDO_MODE4,  0x04, 1800000),
+	BD7181X_LED_REG(WLED, BD7181X_REG_LED_DIMM, 0x3F, BD7181X_REG_LED_CTRL, 0x04, bd7181x_wled_currents),
+};
+
+#ifdef CONFIG_OF
+
+static struct of_regulator_match bd7181x_matches[] = {
+	{ .name = "buck1",	},
+	{ .name = "buck2",	},
+	{ .name = "buck3",	},
+	{ .name = "buck4",	},
+	{ .name = "buck5",	},
+	{ .name = "ldo1",	},
+	{ .name = "ldo2",	},
+	{ .name = "ldo3",	},
+	{ .name = "ldo4",	},
+	{ .name = "ldo5",	},
+	{ .name = "dvref",	},
+	{ .name = "lpsr",	},
+	{ .name = "wled",	},
+};
+
+/**@brief parse bd7181x regulator device tree
+ * @param pdev platform device of bd7181x regulator
+ * @param bd7181x_reg_matches return regualtor matches
+ * @retval 0 parse success
+ * @retval NULL parse fail
+ */
+static int bd7181x_parse_dt_reg_data(
+		struct platform_device *pdev,
+		struct of_regulator_match **reg_matches)
+{
+	// struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *np, *regulators;
+	struct of_regulator_match *matches;
+	int ret, count;
+
+	np = of_node_get(pdev->dev.parent->of_node);
+	regulators = of_find_node_by_name(np, "regulators");
+	if (!regulators) {
+		dev_err(&pdev->dev, "regulator node not found\n");
+		return -EINVAL;
+	}
+
+	count = ARRAY_SIZE(bd7181x_matches);
+	matches = bd7181x_matches;
+
+	ret = of_regulator_match(&pdev->dev, regulators, matches, count);
+	of_node_put(regulators);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Error parsing regulator init data: %d\n",
+			ret);
+		return ret;
+	}
+
+	*reg_matches = matches;
+
+	return 0;
+}
+#else
+static inline int bd7181x_parse_dt_reg_data(
+			struct platform_device *pdev,
+			struct of_regulator_match **reg_matches)
+{
+	*reg_matches = NULL;
+	return 0;
+}
+#endif
+
+/** @brief out32k mode constants */
+static const char* out32k_modes[] = {"open_drain", "cmos"};
+
+/** @brief retrive out32k output mode */
+static ssize_t show_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o;
+
+	o = bd7181x_reg_read(pmic->mfd, BD7181X_REG_OUT32K);
+	o = (o & OUT32K_MODE) != 0;
+
+	return sprintf(buf, "%s\n", out32k_modes[o]);
+}
+
+/** @brief set out32k output mode */
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o, r;
+
+	if (strncmp(buf, out32k_modes[0], strlen(out32k_modes[0])) == 0) {
+		o = 0;
+	} else {
+		o = OUT32K_MODE;
+	}
+
+	r = bd7181x_update_bits(pmic->mfd, BD7181X_REG_OUT32K, OUT32K_MODE, o);
+	if (r < 0) {
+		return r;
+	}
+	return count;
+}
+
+/** @brief retrive out32k output value */
+static ssize_t show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o;
+
+	o = bd7181x_reg_read(pmic->mfd, BD7181X_REG_OUT32K);
+	o = (o & OUT32K_EN) != 0;
+
+	return sprintf(buf, "%d\n", o);
+}
+
+/** @brief set o output value */
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct bd7181x_pmic *pmic = dev_get_drvdata(dev);
+	int o, r;
+
+	if (sscanf(buf, "%d", &o) < 1) {
+		return -EINVAL;
+	}
+
+	if (o != 0) {
+		o = OUT32K_EN;
+	}
+	r = bd7181x_update_bits(pmic->mfd, BD7181X_REG_OUT32K, OUT32K_EN, o);
+	if (r < 0) {
+		return r;
+	}
+	return count;
+}
+
+/** @brief list all supported modes */
+static ssize_t available_modes(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i, r;
+
+	r = 0;
+	for (i = 0; i < ARRAY_SIZE(out32k_modes) && r >= 0; i++) {
+		r += sprintf(buf + r, "%s ", out32k_modes[i]);
+	}
+	r += sprintf(buf + r, "\n");
+
+	return r;
+}
+
+/** @brief list all supported values */
+static ssize_t available_values(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0 1 \n");
+}
+
+static DEVICE_ATTR(out32k_mode, 0666, show_mode, set_mode);
+static DEVICE_ATTR(out32k_value, 0666, show_value, set_value);
+static DEVICE_ATTR(available_mode, 0444, available_modes, NULL);
+static DEVICE_ATTR(available_value, 0444, available_values, NULL);
+
+/** @brief device sysfs attribute table, about o */
+static struct attribute *gpo_attributes[] = {
+	&dev_attr_out32k_mode.attr,
+	&dev_attr_out32k_value.attr,
+	&dev_attr_available_mode.attr,
+	&dev_attr_available_value.attr,
+	NULL
+};
+
+static const struct attribute_group gpo_attr_group = {
+	.attrs	= gpo_attributes,
+};
+
+
+/**@brief probe bd7181x regulator device
+ @param pdev bd7181x regulator platform device
+ @retval 0 success
+ @retval negative fail
+*/
+static int bd7181x_probe(struct platform_device *pdev)
+{
+	struct bd7181x_pmic *pmic;
+	struct bd7181x_board *pdata;
+	struct regulator_config config = {};
+	struct bd7181x *bd7181x = dev_get_drvdata(pdev->dev.parent);
+	struct of_regulator_match *matches = NULL;
+	int i, err;
+
+	pmic = kzalloc(sizeof(*pmic), GFP_KERNEL);
+	if (!pmic) {
+		dev_err(&pdev->dev, "Memory allocation failed for pmic\n");
+		return -ENOMEM;
+	}
+
+	memcpy(pmic->descs, bd7181x_regulators,	sizeof(pmic->descs));
+
+	pmic->dev = &pdev->dev;
+	pmic->mfd = bd7181x;
+	platform_set_drvdata(pdev, pmic);
+
+	bd7181x_clear_bits(pmic->mfd, BD7181X_REG_PWRCTRL, RESTARTEN); // Disable to go to ship-mode
+	bd7181x_clear_bits(pmic->mfd, BD7181X_REG_GPO, RESTARTEN); // Turn OFF the green LED
+	bd7181x_set_bits(pmic->mfd, BD7181X_REG_CHG_SET1, CHG_EN); // Enable charger
+
+	pdata = dev_get_platdata(bd7181x->dev);
+	if (!pdata && bd7181x->dev->of_node) {
+		bd7181x_parse_dt_reg_data(pdev,	&matches);
+		if (matches == NULL) {
+			dev_err(&pdev->dev, "Platform data not found\n");
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < BD7181X_REGULATOR_CNT; i++) {
+		struct regulator_init_data *init_data;
+		struct regulator_desc *desc;
+		struct regulator_dev *rdev;
+
+		desc = &pmic->descs[i].desc;
+		desc->name = bd7181x_matches[i].name;
+		
+		if (pdata) {
+			init_data = pdata->init_data[i];
+		} else {
+			init_data = matches[i].init_data;
+		}
+
+		config.dev = pmic->dev;
+		config.init_data = init_data;
+		config.driver_data = pmic;
+		config.regmap = bd7181x->regmap;
+		config.of_node = matches[i].of_node;
+
+		rdev = regulator_register(desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(bd7181x->dev,
+				"failed to register %s regulator\n",
+				desc->name);
+			err = PTR_ERR(rdev);
+			goto err;
+		}
+		pmic->rdev[i] = rdev;
+	}
+
+	err = sysfs_create_group(&pdev->dev.kobj, &gpo_attr_group);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to create attribute group: %d\n", err);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	while (--i >= 0)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
+	return err;
+}
+
+/**@brief remove bd7181x regulator device
+ @param pdev bd7181x regulator platform device
+ @return 0
+*/
+static int __exit bd7181x_remove(struct platform_device *pdev)
+{
+	struct bd7181x_pmic *pmic = platform_get_drvdata(pdev);
+	int i;
+
+	sysfs_remove_group(&pdev->dev.kobj, &gpo_attr_group);
+
+	for (i = 0; i < BD7181X_REGULATOR_CNT; i++)
+		regulator_unregister(pmic->rdev[i]);
+
+	kfree(pmic);
+	return 0;
+}
+
+static struct platform_driver bd7181x_driver = {
+	.driver = {
+		.name = "bd7181x-pmic",
+		.owner = THIS_MODULE,
+	},
+	.probe = bd7181x_probe,
+	.remove = bd7181x_remove,
+};
+
+/**@brief module initialize function */
+static int __init bd7181x_init(void)
+{
+	return platform_driver_register(&bd7181x_driver);
+}
+subsys_initcall(bd7181x_init);
+
+/**@brief module deinitialize function */
+static void __exit bd7181x_cleanup(void)
+{
+	platform_driver_unregister(&bd7181x_driver);
+}
+module_exit(bd7181x_cleanup);
+
+MODULE_AUTHOR("Tony Luo <luofc@embedinfo.com>");
+MODULE_DESCRIPTION("BD71815/BD71817 voltage regulator driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bd7181x-pmic");
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index db933de..7cf924b 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -539,6 +539,15 @@ config RTC_DRV_S5M
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-s5m.
 
+config RTC_DRV_BD7181X
+	tristate "BD71815/BD71817 RTC"
+	depends on RTC_CLASS && MFD_BD7181X
+	help
+	  If you say yes here you get support for the RTC on the
+          RoHM BD71815/BD71817 chips.
+
+          This driver can also be built as a module.
+
 endif # I2C
 
 comment "SPI RTC drivers"
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index b427bf7..48779e9 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -105,6 +105,7 @@ obj-$(CONFIG_RTC_DRV_RS5C313)	+= rtc-rs5c313.o
 obj-$(CONFIG_RTC_DRV_RS5C348)	+= rtc-rs5c348.o
 obj-$(CONFIG_RTC_DRV_RS5C372)	+= rtc-rs5c372.o
 obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
+obj-$(CONFIG_RTC_DRV_BD7181X)	+= rtc-bd7181x.o
 obj-$(CONFIG_RTC_DRV_RX4581)	+= rtc-rx4581.o
 obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
diff --git a/drivers/rtc/rtc-bd7181x.c b/drivers/rtc/rtc-bd7181x.c
new file mode 100644
index 0000000..2f15517
--- /dev/null
+++ b/drivers/rtc/rtc-bd7181x.c
@@ -0,0 +1,417 @@
+/*
+ * @file RoHM BD71815/BD71817 Real Time Clock interface
+ *
+ * Copyright (C) 2014 Embest Technology Co. Ltd. Inc.
+ *
+ * @author Peter Yang <yanglsh@embest-tech.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/mfd/bd7181x.h>
+
+/** @brief bd7181x rtc struct */
+struct bd7181x_rtc {
+	struct rtc_device	*rtc;		/**< system rtc device */
+	int irq;				/**< rtc irq */
+};
+
+/* @brief Total number of RTC registers needed to set time*/
+// #define NUM_TIME_REGS	(BD7181X_REG_YEAR - BD7181X_REG_SEC + 1)
+
+/**@brief enable or disable rtc alarm irq
+ * @param dev rtc device of system
+ * @param enabled enable if non-zero
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_alarm_irq_enable(struct device *dev, unsigned enabled)
+{
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	u8 val = 0;
+
+	if (enabled)
+		val = ALM0;
+
+	return regmap_write(mfd->regmap, BD7181X_REG_INT_EN_12, val);
+}
+
+/**@brief bd7181x rtc time convert to linux time
+ * @param tm linux rtc time
+ * @param hw_rtc bd7181x rtc time
+ * @return argument tm
+ */
+static struct rtc_time* hw_to_rtc_time(struct rtc_time* tm, const struct bd7181x_rtc_alarm* hw_rtc) {
+	u8 hour;
+
+	tm->tm_sec = bcd2bin(hw_rtc->sec);
+	tm->tm_min = bcd2bin(hw_rtc->min);
+	hour = hw_rtc->hour & ~HOUR_24HOUR;
+	tm->tm_hour = bcd2bin(hour);
+	tm->tm_mday = bcd2bin(hw_rtc->day);
+	tm->tm_mon = bcd2bin(hw_rtc->month) - 1;
+	tm->tm_year = bcd2bin(hw_rtc->year) + 100;
+	return tm;
+}
+
+/**@brief linux time convert bd7181x rtc time
+ * @param hw_rtc bd7181x rtc time
+ * @param tm linux rtc time
+ * @return argument hw_rtc
+ */
+static struct bd7181x_rtc_alarm* rtc_time_to_hw(struct bd7181x_rtc_alarm* hw_rtc, const struct rtc_time* tm) {
+	hw_rtc->sec = bin2bcd(tm->tm_sec);
+	hw_rtc->min = bin2bcd(tm->tm_min);
+	hw_rtc->hour = HOUR_24HOUR | bin2bcd(tm->tm_hour);
+	hw_rtc->day = bin2bcd(tm->tm_mday);
+	hw_rtc->month = bin2bcd(tm->tm_mon + 1);
+	hw_rtc->year = bin2bcd(tm->tm_year - 100);
+
+	return hw_rtc;
+}
+
+/*
+ * Gets current bd7181x RTC time and date parameters.
+ *
+ * The RTC's time/alarm representation is not what gmtime(3) requires
+ * Linux to use:
+ *
+ *  - Months are 1..12 vs Linux 0-11
+ *  - Years are 0..99 vs Linux 1900..N (we assume 21st century)
+ */
+/**@brief read date/time from bd7181x rtc
+ * @param dev rtc device of system
+ * @param tm date/time store target
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	ret = regmap_bulk_read(mfd->regmap, BD7181X_REG_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "reading from RTC failed with err:%d\n", ret);
+		return ret;
+	}
+
+	hw_to_rtc_time(tm, rtc_data);
+
+	return ret;
+}
+
+/**@brief write date/time to bd7181x rtc
+ * @param dev rtc device of system
+ * @param tm date/time source
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	rtc_time_to_hw(rtc_data, tm);
+
+	/* update all the time registers in one shot */
+	ret = regmap_bulk_write(mfd->regmap, BD7181X_REG_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "rtc_set_time error %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/**@brief Gets current bd7181x RTC alarm time.
+ * @param dev rtc device of system
+ * @param alm alarm date/time store target
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	u32 int_val;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	ret = regmap_bulk_read(mfd->regmap, BD7181X_REG_ALM0_SEC, rtc_data, sizeof rtc_data);
+	if (ret < 0) {
+		dev_err(dev, "rtc_read_alarm error %d\n", ret);
+		return ret;
+	}
+	
+	hw_to_rtc_time(&alm->time, rtc_data);
+
+	ret = regmap_read(mfd->regmap, BD7181X_REG_INT_EN_12, &int_val);
+	if (ret < 0)
+		return ret;
+
+	if (int_val & ALM0)
+		alm->enabled = 1;
+
+	return ret;
+}
+
+/**@brief Set current bd7181x RTC alarm time
+ * @param dev rtc device of system
+ * @param alm alarm date/time to set
+ * @retval 0 success
+ * @retval negative error number
+ */
+static int bd7181x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
+{
+	struct bd7181x_rtc_alarm rtc_data[1];
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	int ret;
+
+	// printk("%s() L%d\n", __func__, __LINE__);
+
+	ret = bd7181x_rtc_alarm_irq_enable(dev, 0);
+	if (ret)
+		return ret;
+
+	rtc_time_to_hw(rtc_data, &alm->time);
+
+	/* update all the alarm registers in one shot */
+	ret = regmap_bulk_write(mfd->regmap, BD7181X_REG_ALM0_SEC, rtc_data, sizeof rtc_data);
+	if (ret) {
+		dev_err(dev, "rtc_set_alarm error %d\n", ret);
+		return ret;
+	}
+
+	if (alm->enabled)
+		ret = bd7181x_rtc_alarm_irq_enable(dev, 1);
+
+	return ret;
+}
+
+/**@brief bd7181x rtc alarm interrupt
+ * @param irq system irq
+ * @param rtc rtc device of system
+ * @retval IRQ_HANDLED success
+ * @retval IRQ_NONE error
+ */
+static irqreturn_t bd7181x_rtc_interrupt(int irq, void *rtc)
+{
+	struct device *dev = rtc;
+	unsigned long events = 0;
+	struct bd7181x *mfd = dev_get_drvdata(dev->parent);
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+	int ret;
+	u32 rtc_reg;
+
+	printk("bd7181x_vbat_interrupt() in.\n");
+
+	ret = regmap_read(mfd->regmap, BD7181X_REG_INT_STAT_12, &rtc_reg);
+	if (ret)
+		return IRQ_NONE;
+
+	printk("BD7181X_REG_INT_STAT_12=0x%x\n", rtc_reg);
+
+	if (rtc_reg & ALM0)
+		events = RTC_IRQF | RTC_AF;
+
+	ret = regmap_write(mfd->regmap, BD7181X_REG_INT_STAT_12, rtc_reg);
+	if (ret)
+		return IRQ_NONE;
+
+	printk("\n~~~IRQ ALARM.\n");
+
+	/* Notify RTC core on event */
+	rtc_update_irq(bd_rtc->rtc, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+/** @brief function operations definition */
+static struct rtc_class_ops bd7181x_rtc_ops = {
+	.read_time	= bd7181x_rtc_read_time,
+	.set_time	= bd7181x_rtc_set_time,
+	.read_alarm	= bd7181x_rtc_read_alarm,
+	.set_alarm	= bd7181x_rtc_set_alarm,
+	.alarm_irq_enable = bd7181x_rtc_alarm_irq_enable,
+};
+
+/**@brief probe bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @retval 0 success
+ @retval negative fail
+*/
+static int bd7181x_rtc_probe(struct platform_device *pdev)
+{
+	struct bd7181x *bd7181x = NULL;
+	struct bd7181x_rtc *bd_rtc = NULL;
+	int ret;
+	int irq;
+	u32 rtc_reg;
+
+	bd7181x = dev_get_drvdata(pdev->dev.parent);
+
+	bd_rtc = devm_kzalloc(&pdev->dev, sizeof(struct bd7181x_rtc),
+			GFP_KERNEL);
+	if (!bd_rtc)
+		return -ENOMEM;
+
+	/* Clear pending interrupts */
+	ret = regmap_read(bd7181x->regmap, BD7181X_REG_INT_STAT_12, &rtc_reg);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_write(bd7181x->regmap, BD7181X_REG_INT_STAT_12, rtc_reg);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&pdev->dev, "Enabling rtc-bd7181x.\n");
+
+	#if 0
+	/* Enable RTC alarm interrupt */
+	ret = regmap_update_bits(bd7181x->regmap, BD7181X_REG_INT_EN_00, ALMALE, ALMALE);
+	if (ret < 0)
+		return ret;
+	#endif
+	/* Disable ALM0 mask */
+	ret = regmap_write(bd7181x->regmap, BD7181X_REG_ALM0_MASK, 0);
+	if (ret < 0)
+		return ret;
+
+	irq  = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_warn(&pdev->dev, "Wake up is not possible as irq = %d\n", irq);
+		return -ENXIO;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+		bd7181x_rtc_interrupt, IRQF_TRIGGER_LOW | IRQF_EARLY_RESUME,
+		dev_name(&pdev->dev), &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ is not free.\n");
+		return ret;
+	}
+	bd_rtc->irq = irq;
+	device_set_wakeup_capable(&pdev->dev, 1);
+
+	bd_rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
+		&bd7181x_rtc_ops, THIS_MODULE);
+	if (IS_ERR(bd_rtc->rtc)) {
+		ret = PTR_ERR(bd_rtc->rtc);
+		dev_err(&pdev->dev, "RTC device register: err %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, bd_rtc);
+
+	return 0;
+}
+
+/*
+ * Disable bd7181x RTC interrupts.
+ * Sets status flag to free.
+ */
+/**@brief remove bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @return 0
+*/
+static int bd7181x_rtc_remove(struct platform_device *pdev)
+{
+	bd7181x_rtc_alarm_irq_enable(&pdev->dev, 0);
+
+	return 0;
+}
+
+/**@brief shutdown bd7181x rtc device
+ @param pdev bd7181x rtc platform device
+ @return void
+*/
+static void bd7181x_rtc_shutdown(struct platform_device *pdev)
+{
+	/* mask timer interrupts, but leave alarm interrupts on to enable
+	   power-on when alarm is triggered */
+	bd7181x_rtc_alarm_irq_enable(&pdev->dev, 0);
+}
+
+#ifdef CONFIG_PM_SLEEP
+/**@brief suspend bd7181x rtc device
+ * @param dev rtc device of system
+ * @retval 0
+ */
+static int bd7181x_rtc_suspend(struct device *dev)
+{
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(bd_rtc->irq);
+	return 0;
+}
+
+/**@brief resume bd7181x rtc device
+ * @param dev rtc device of system
+ * @retval 0
+ */
+static int bd7181x_rtc_resume(struct device *dev)
+{
+	struct bd7181x_rtc *bd_rtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(bd_rtc->irq);
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(bd7181x_rtc_pm_ops, bd7181x_rtc_suspend, bd7181x_rtc_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id bd7181x_rtc_of_match[] = {
+	{.compatible = "ti,bd7181x-rtc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bd7181x_rtc_of_match);
+#endif
+
+static struct platform_driver bd7181xrtc_driver = {
+	.probe		= bd7181x_rtc_probe,
+	.remove		= bd7181x_rtc_remove,
+	.shutdown	= bd7181x_rtc_shutdown,
+	.driver		= {
+		.owner		= THIS_MODULE,
+		.name		= "bd7181x-rtc",
+		.pm		= &bd7181x_rtc_pm_ops,
+		.of_match_table = of_match_ptr(bd7181x_rtc_of_match),
+	},
+};
+
+/**@brief module initialize function */
+static int __init bd7181x_rtc_init(void)
+{
+	return platform_driver_register(&bd7181xrtc_driver);
+}
+module_init(bd7181x_rtc_init);
+
+/**@brief module deinitialize function */
+static void __exit bd7181x_rtc_exit(void)
+{
+	platform_driver_unregister(&bd7181xrtc_driver);
+}
+module_exit(bd7181x_rtc_exit);
+
+MODULE_AUTHOR("Peter Yang <yanglsh@embest-tech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:bd7181x-rtc");
diff --git a/drivers/video/mxc/mxc_lcdif.c b/drivers/video/mxc/mxc_lcdif.c
index d635edd..b7f0e42 100644
--- a/drivers/video/mxc/mxc_lcdif.c
+++ b/drivers/video/mxc/mxc_lcdif.c
@@ -48,6 +48,12 @@ static struct fb_videomode lcdif_modedb[] = {
 	FB_SYNC_CLK_LAT_FALL,
 	FB_VMODE_NONINTERLACED,
 	0,},
+	{
+	/* 800x480 @ 49 Hz , pixel clk @ 33.5MHz */
+	"EA7-WVGA", 49, 800, 480, 33500, 89, 164, 75, 75, 10, 10,
+	FB_SYNC_CLK_LAT_FALL,
+	FB_VMODE_NONINTERLACED,
+	0,},
 };
 static int lcdif_modedb_sz = ARRAY_SIZE(lcdif_modedb);
 
diff --git a/include/linux/mfd/bd7181x.h b/include/linux/mfd/bd7181x.h
new file mode 100644
index 0000000..ab1b45e
--- /dev/null
+++ b/include/linux/mfd/bd7181x.h
@@ -0,0 +1,562 @@
+/**
+ * @file bd7181x.h  ROHM BD71815GW/BD71817GW header file
+ *
+ * Copyright 2014 Embest Technology Co. Ltd. Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under  the terms of the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ * @author yanglsh@embest-tech.com
+ */
+
+#ifndef __LINUX_MFD_BD7181X_H
+#define __LINUX_MFD_BD7181X_H
+
+#include <linux/regmap.h>
+
+// LDO5VSEL_EQ_H
+// define to 1 when LDO5VSEL connect to High
+// define to 0 when LDO5VSEL connect to Low
+#define LDO5VSEL_EQ_H		1
+
+#ifndef LDO5VSEL_EQ_H
+	#error define LDO5VSEL_EQ_H to 1 when connect to High, to 0 when connect to Low
+#else
+	#if LDO5VSEL_EQ_H == 1
+		#define BD7181X_REG_LDO5_VOLT BD7181X_REG_LDO5_VOLT_H
+	#elif LDO5VSEL_EQ_H == 0
+		#define BD7181X_REG_LDO5_VOLT BD7181X_REG_LDO5_VOLT_L
+	#else
+		#error  Define LDO5VSEL_EQ_H only to 0 or 1
+	#endif
+#endif
+
+enum {
+	BD7181X_BUCK1	=	0,
+	BD7181X_BUCK2,
+	BD7181X_BUCK3,
+	BD7181X_BUCK4,
+	BD7181X_BUCK5,
+	// General Purpose
+	BD7181X_LDO1,
+	BD7181X_LDO2,
+	BD7181X_LDO3,
+	// LDOs for SD Card and SD Card Interface
+	BD7181X_LDO4,
+	BD7181X_LDO5,
+	// LDO for DDR Reference Voltage
+	BD7181X_LDODVREF,
+	// LDO for Secure Non-Volatile Storage
+	// BD7181X_LDOSNVS,
+	// LDO for Low-Power State Retention
+	BD7181X_LDOLPSR,
+	BD7181X_WLED,
+	BD7181X_REGULATOR_CNT,
+};
+
+#define BD7181X_SUPPLY_STATE_ENABLED    0x1
+
+enum {
+	BD7181X_REG_DEVICE		=	0,
+	BD7181X_REG_PWRCTRL,
+	BD7181X_REG_BUCK1_MODE,
+	BD7181X_REG_BUCK2_MODE,
+	BD7181X_REG_BUCK3_MODE,
+	BD7181X_REG_BUCK4_MODE,
+	BD7181X_REG_BUCK5_MODE,
+	BD7181X_REG_BUCK1_VOLT_H,
+	// 0x08
+	BD7181X_REG_BUCK1_VOLT_L,
+	BD7181X_REG_BUCK2_VOLT_H,
+	BD7181X_REG_BUCK2_VOLT_L,
+	BD7181X_REG_BUCK3_VOLT,
+	BD7181X_REG_BUCK4_VOLT,
+	BD7181X_REG_BUCK5_VOLT,
+	BD7181X_REG_LED_CTRL,
+	BD7181X_REG_LED_DIMM,
+	// 0x10
+	BD7181X_REG_LDO_MODE1,
+	BD7181X_REG_LDO_MODE2,
+	BD7181X_REG_LDO_MODE3,
+	BD7181X_REG_LDO_MODE4,
+	BD7181X_REG_LDO1_VOLT,
+	BD7181X_REG_LDO2_VOLT,
+	BD7181X_REG_LDO3_VOLT,
+	BD7181X_REG_LDO4_VOLT,
+	// 0x18
+	BD7181X_REG_LDO5_VOLT_H,
+	BD7181X_REG_LDO5_VOLT_L,
+	BD7181X_REG_BUCK_PD_DIS,
+	BD7181X_REG_LDO_PD_DIS,
+	BD7181X_REG_GPO,
+	BD7181X_REG_OUT32K,
+	BD7181X_REG_SEC,
+	BD7181X_REG_MIN,
+	// 0x20
+	BD7181X_REG_HOUR,
+	BD7181X_REG_WEEK,
+	BD7181X_REG_DAY,
+	BD7181X_REG_MONTH,
+	BD7181X_REG_YEAR,
+	BD7181X_REG_ALM0_SEC,
+
+	// 0x2C
+	BD7181X_REG_ALM1_SEC		=	0x2C,
+
+	// 0x33
+	BD7181X_REG_ALM0_MASK		=	0x33,
+	BD7181X_REG_ALM1_MASK,
+	BD7181X_REG_ALM2,
+	BD7181X_REG_TRIM,
+	BD7181X_REG_CONF,
+	// 0x38
+	BD7181X_REG_SYS_INIT,
+	BD7181X_REG_CHG_STATE,
+	BD7181X_REG_CHG_LAST_STATE,
+	BD7181X_REG_BAT_STAT,
+	BD7181X_REG_DCIN_STAT,
+	BD7181X_REG_VSYS_STAT,
+	BD7181X_REG_CHG_STAT,
+	BD7181X_REG_CHG_WDT_STAT,
+	// 0x40
+	BD7181X_REG_BAT_TEMP,
+	BD7181X_REG_IGNORE_0,
+	BD7181X_REG_INHIBIT_0,
+	BD7181X_REG_DCIN_CLPS,
+	BD7181X_REG_VSYS_REG,
+	BD7181X_REG_VSYS_MAX,
+	BD7181X_REG_VSYS_MIN,
+	BD7181X_REG_CHG_SET1,
+	// 0x48
+	BD7181X_REG_CHG_SET2,
+	BD7181X_REG_CHG_WDT_PRE,
+	BD7181X_REG_CHG_WDT_FST,
+	BD7181X_REG_CHG_IPRE,
+	BD7181X_REG_CHG_IFST,
+	BD7181X_REG_CHG_IFST_TERM,
+	BD7181X_REG_CHG_VPRE,
+	BD7181X_REG_CHG_VBAT_1,
+	// 0x50
+	BD7181X_REG_CHG_VBAT_2,
+	BD7181X_REG_CHG_VBAT_3,
+	BD7181X_REG_CHG_LED_1,
+	BD7181X_REG_VF_TH,
+	BD7181X_REG_BAT_SET_1,
+	BD7181X_REG_BAT_SET_2,
+	BD7181X_REG_BAT_SET_3,
+	BD7181X_REG_ALM_VBAT_TH_U,
+	// 0x58
+	BD7181X_REG_ALM_VBAT_TH_L,
+	BD7181X_REG_ALM_DCIN_TH,
+	BD7181X_REG_ALM_VSYS_TH,
+	BD7181X_REG_VM_IBAT_U,
+	BD7181X_REG_VM_IBAT_L,
+	BD7181X_REG_VM_VBAT_U,
+	BD7181X_REG_VM_VBAT_L,
+	BD7181X_REG_VM_BTMP,
+	// 0x60
+	BD7181X_REG_VM_VTH,
+	BD7181X_REG_VM_DCIN_U,
+	BD7181X_REG_VM_DCIN_L,
+	BD7181X_REG_VM_VSYS,
+	BD7181X_REG_VM_VF,
+	BD7181X_REG_VM_OCI_PRE_U,
+	BD7181X_REG_VM_OCI_PRE_L,
+	BD7181X_REG_VM_OCV_PRE_U,
+	// 0x68
+	BD7181X_REG_VM_OCV_PRE_L,
+	BD7181X_REG_VM_OCI_PST_U,
+	BD7181X_REG_VM_OCI_PST_L,
+	BD7181X_REG_VM_OCV_PST_U,
+	BD7181X_REG_VM_OCV_PST_L,
+	BD7181X_REG_VM_SA_VBAT_U,
+	BD7181X_REG_VM_SA_VBAT_L,
+	BD7181X_REG_VM_SA_IBAT_U,
+	// 0x70
+	BD7181X_REG_VM_SA_IBAT_L,
+	BD7181X_REG_CC_CTRL,
+	BD7181X_REG_CC_BATCAP1_TH_U,
+	BD7181X_REG_CC_BATCAP1_TH_L,
+	BD7181X_REG_CC_BATCAP2_TH_U,
+	BD7181X_REG_CC_BATCAP2_TH_L,
+	BD7181X_REG_CC_BATCAP3_TH_U,
+	BD7181X_REG_CC_BATCAP3_TH_L,
+	// 0x78
+	BD7181X_REG_CC_STAT,
+	BD7181X_REG_CC_CCNTD_3,
+	BD7181X_REG_CC_CCNTD_2,
+	BD7181X_REG_CC_CCNTD_1,
+	BD7181X_REG_CC_CCNTD_0,
+	BD7181X_REG_CC_CURCD_U,
+	BD7181X_REG_CC_CURCD_L,
+	BD7181X_REG_VM_OCUR_THR_1,
+	// 0x80
+	BD7181X_REG_VM_OCUR_DUR_1,
+	BD7181X_REG_VM_OCUR_THR_2,
+	BD7181X_REG_VM_OCUR_DUR_2,
+	BD7181X_REG_VM_OCUR_THR_3,
+	BD7181X_REG_VM_OCUR_DUR_3,
+	BD7181X_REG_VM_OCUR_MON,
+	BD7181X_REG_VM_BTMP_OV_THR,
+	BD7181X_REG_VM_BTMP_OV_DUR,
+	// 0x88
+	BD7181X_REG_VM_BTMP_LO_THR,
+	BD7181X_REG_VM_BTMP_LO_DUR,
+	BD7181X_REG_VM_BTMP_MON,
+	BD7181X_REG_INT_EN_01,
+	// 0x95
+	BD7181X_REG_INT_EN_11		=	0x95,
+	// 0x96
+	BD7181X_REG_INT_EN_12		=	0x96,
+	BD7181X_REG_INT_STAT,
+
+	// 0x98
+	BD7181X_REG_INT_STAT_01,
+	BD7181X_REG_INT_STAT_02,
+	BD7181X_REG_INT_STAT_03,
+	BD7181X_REG_INT_STAT_04,
+	BD7181X_REG_INT_STAT_05,
+	BD7181X_REG_INT_STAT_06,
+	BD7181X_REG_INT_STAT_07,
+	BD7181X_REG_INT_STAT_08,
+
+	// 0xA0
+	BD7181X_REG_INT_STAT_09,
+	BD7181X_REG_INT_STAT_10,
+	BD7181X_REG_INT_STAT_11,
+	BD7181X_REG_INT_STAT_12,
+	BD7181X_REG_INT_UPDATE,
+
+	// 0xC0
+	BD7181X_REG_VM_VSYS_U		=	0xC0,
+	BD7181X_REG_VM_VSYS_L,
+	BD7181X_REG_VM_SA_VSYS_U,
+	BD7181X_REG_VM_SA_VSYS_L,
+
+	// 0xD0
+	BD7181X_REG_VM_SA_IBAT_MIN_U	=	0xD0,
+	BD7181X_REG_VM_SA_IBAT_MIN_L,
+	BD7181X_REG_VM_SA_IBAT_MAX_U,
+	BD7181X_REG_VM_SA_IBAT_MAX_L,
+	BD7181X_REG_VM_SA_VBAT_MIN_U,
+	BD7181X_REG_VM_SA_VBAT_MIN_L,
+	BD7181X_REG_VM_SA_VBAT_MAX_U,
+	BD7181X_REG_VM_SA_VBAT_MAX_L,
+	BD7181X_REG_VM_SA_VSYS_MIN_U,
+	BD7181X_REG_VM_SA_VSYS_MIN_L,
+	BD7181X_REG_VM_SA_VSYS_MAX_U,
+	BD7181X_REG_VM_SA_VSYS_MAX_L,
+	BD7181X_REG_VM_SA_MINMAX_CLR,
+
+	// 0xE0
+	BD7181X_REG_REX_CCNTD_3		=	0xE0,
+	BD7181X_REG_REX_CCNTD_2,
+	BD7181X_REG_REX_CCNTD_1,
+	BD7181X_REG_REX_CCNTD_0,
+	BD7181X_REG_REX_SA_VBAT_U,
+	BD7181X_REG_REX_SA_VBAT_L,
+	BD7181X_REG_REX_CTRL_1,
+	BD7181X_REG_REX_CTRL_2,
+	BD7181X_REG_FULL_CCNTD_3,
+	BD7181X_REG_FULL_CCNTD_2,
+	BD7181X_REG_FULL_CCNTD_1,
+	BD7181X_REG_FULL_CCNTD_0,
+	BD7181X_REG_FULL_CTRL,
+
+	// 0xF0
+	BD7181X_REG_CCNTD_CHG_3		=	0xF0,
+	BD7181X_REG_CCNTD_CHG_2,
+
+	// 0xFE
+	BD7181X_REG_TEST_MODE		=	0xFE,
+	BD7181X_MAX_REGISTER,
+};
+
+/* BD7181X_REG_LDO1_CTRL bits */
+#define LDO1_EN					0x01
+#define LDO2_EN					0x02
+#define LDO3_EN					0x04
+#define DVREF_EN				0x08
+#define VOSNVS_SW_EN				0x10
+#define VOLT_MASK				0x3F
+
+/* BD7181X_REG_OUT32K bits */
+#define OUT32K_EN				0x01
+#define OUT32K_MODE				0x02
+
+/* BD7181X_REG_BAT_STAT bits */
+#define BAT_DET					0x20
+#define BAT_DET_OFFSET				5
+#define BAT_DET_DONE				0x10
+#define VBAT_OV					0x08
+#define DBAT_DET				0x01
+
+/* BD7181X_REG_VBUS_STAT bits */
+#define VBUS_DET				0x01
+
+#define BUCK1_RAMPRATE_10MV_US			0x0
+#define BUCK1_RAMPRATE_5MV_US			0x1
+#define BUCK1_RAMPRATE_2P5MV_US			0x2
+#define BUCK1_RAMPRATE_1P25MV_US		0x3a
+
+/* BD7181X_REG_ALM0_MASK bits */
+#define A0_ONESEC				0x80
+
+/* BD7181X_REG_INT_EN_00 bits */
+#define ALMALE					0x1
+
+/* BD7181X_REG_INT_STAT_03 bits */
+#define DCIN_MON_DET				0x02
+#define DCIN_MON_RES				0x01
+
+/* BD71805_REG_INT_STAT_08 bits */
+#define VBAT_MON_DET				0x02
+#define VBAT_MON_RES				0x01
+
+/* BD71805_REG_INT_STAT_11 bits */
+#define	INT_STAT_11_VF_DET			0x80
+#define	INT_STAT_11_VF_RES			0x40
+#define	INT_STAT_11_VF125_DET		0x20
+#define	INT_STAT_11_VF125_RES		0x10
+#define	INT_STAT_11_OVTMP_DET		0x08
+#define	INT_STAT_11_OVTMP_RES		0x04
+#define	INT_STAT_11_LOTMP_DET		0x02
+#define	INT_STAT_11_LOTMP_RES		0x01
+
+#define VBAT_MON_DET				0x02
+#define VBAT_MON_RES				0x01
+
+/* BD7181X_REG_PWRCTRL bits */
+#define RESTARTEN				0x01
+
+/* BD7181X_REG_GPO bits */
+#define READY_FORCE_LOW				0x04
+
+/* BD7181X_REG_CHG_SET1 bits */
+#define CHG_EN					0x01
+
+/* BD7181X interrupt masks */
+enum {
+	BD7181X_INT_EN_01_BUCKAST_MASK	=	0x0F,
+	BD7181X_INT_EN_02_DCINAST_MASK	=	0x3E,
+	BD7181X_INT_EN_03_DCINAST_MASK	=	0x03,
+	BD7181X_INT_EN_04_VSYSAST_MASK	=	0xCF,
+	BD7181X_INT_EN_05_CHGAST_MASK	=	0xFC,
+	BD7181X_INT_EN_06_BATAST_MASK	=	0xF3,
+	BD7181X_INT_EN_07_BMONAST_MASK	=	0xFE,
+	BD7181X_INT_EN_08_BMONAST_MASK	=	0x03,
+	BD7181X_INT_EN_09_BMONAST_MASK	=	0x07,
+	BD7181X_INT_EN_10_BMONAST_MASK	=	0x3F,
+	BD7181X_INT_EN_11_TMPAST_MASK	=	0xFF,
+	BD7181X_INT_EN_12_ALMAST_MASK	=	0x07,
+};
+/* BD7181X interrupt irqs */
+enum {
+	BD7181X_IRQ_BUCK_01		=	0x0,
+	BD7181X_IRQ_DCIN_02,
+	BD7181X_IRQ_DCIN_03,
+	BD7181X_IRQ_VSYS_04,
+	BD7181X_IRQ_CHARGE_05,
+	BD7181X_IRQ_BAT_06,
+	BD7181X_IRQ_BAT_MON_07,
+	BD7181X_IRQ_BAT_MON_08,
+	BD7181X_IRQ_BAT_MON_09,
+	BD7181X_IRQ_BAT_MON_10,
+	BD7181X_IRQ_TEMPERATURE_11,
+	BD7181X_IRQ_ALARM_12,
+};
+
+/* BD7181X_REG_INT_EN_12 bits */
+#define ALM0					0x1
+
+/* BD7181X_REG_HOUR bits */
+#define HOUR_24HOUR				0x80
+
+/* BD7181X_REG_CC_CTRL bits */
+#define CCNTRST					0x80
+#define CCNTENB					0x40
+#define CCCALIB					0x20
+
+/* BD7181X_REG_CHG_SET1 bits */
+#define WDT_AUTO				0x40
+
+/* BD7181X_REG_CC_CURCD */
+#define CURDIR_Discharging			0x8000
+
+/* BD7181X_REG_VM_SA_IBAT */
+#define IBAT_SA_DIR_Discharging			0x8000
+
+/* BD7181X_REG_VM_SA_MINMAX_CLR bits */
+#define VSYS_SA_MIN_CLR				0x10
+#define VBAT_SA_MIN_CLR				0x01
+
+/* BD7181X_REG_REX_CTRL_1 bits */
+#define REX_CLR					0x10
+
+/* BD7181X_REG_REX_CTRL_1 bits */
+#define REX_PMU_STATE_MASK			0x04
+
+/* BD7181X_REG_FULL_CTRL bits */
+#define FULL_CLR				0x10
+
+/* BD7181X_REG_LED_CTRL bits */
+#define CHGDONE_LED_EN				0x10
+
+/** @brief charge state enumuration */
+enum CHG_STATE {
+	CHG_STATE_SUSPEND = 0x0,		/**< suspend state */
+	CHG_STATE_TRICKLE_CHARGE,		/**< trickle charge state */
+	CHG_STATE_PRE_CHARGE,			/**< precharge state */
+	CHG_STATE_FAST_CHARGE,			/**< fast charge state */
+	CHG_STATE_TOP_OFF,			/**< top off state */
+	CHG_STATE_DONE,				/**< charge complete */
+};
+
+/** @brief rtc or alarm registers structure */
+struct bd7181x_rtc_alarm {
+	u8	sec;
+	u8	min;
+	u8	hour;
+	u8	week;
+	u8	day;
+	u8	month;
+	u8	year;
+};
+
+struct bd7181x;
+
+/**
+ * @brief Board platform data may be used to initialize regulators.
+ */
+
+struct bd7181x_board {
+	struct regulator_init_data *init_data[BD7181X_REGULATOR_CNT];
+	/**< regulator initialize data */
+	int	gpio_intr;		/**< gpio connected to bd7181x INTB */
+	int	irq_base;		/**< bd7181x sub irqs base #  */
+};
+
+/**
+ * @brief bd7181x sub-driver chip access routines
+ */
+
+struct bd7181x {
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct mutex io_mutex;
+	unsigned int id;
+
+	/* IRQ Handling */
+	int 	chip_irq;		/**< bd7181x irq to host cpu */
+	struct regmap_irq_chip_data *irq_data;
+
+	/* Client devices */
+	struct bd7181x_pmic *pmic;	/**< client device regulator */
+	struct bd7181x_power *power;	/**< client device battery */
+
+	struct bd7181x_board *of_plat_data;
+	/**< Device node parsed board data */
+};
+
+static inline int bd7181x_chip_id(struct bd7181x *bd7181x)
+{
+	return bd7181x->id;
+}
+
+
+/**
+ * @brief bd7181x_reg_read
+ * read single register's value of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @return register value if success
+ *         error number if fail
+ */
+static inline int bd7181x_reg_read(struct bd7181x *bd7181x, u8 reg)
+{
+	int r, val;
+
+	r = regmap_read(bd7181x->regmap, reg, &val);
+	if (r < 0) {
+		return r;
+	}
+	return val;
+}
+
+/**
+ * @brief bd7181x_reg_write
+ * write single register of bd7181x
+ * @param bd7181x device to write
+ * @param reg register address
+ * @param val value to write
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_reg_write(struct bd7181x *bd7181x, u8 reg,
+		unsigned int val)
+{
+	return regmap_write(bd7181x->regmap, reg, val);
+}
+
+/**
+ * @brief bd7181x_set_bits
+ * set bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+static inline int bd7181x_set_bits(struct bd7181x *bd7181x, u8 reg,
+		u8 mask)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, mask);
+}
+
+/**
+ * @brief bd7181x_clear_bits
+ * clear bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_clear_bits(struct bd7181x *bd7181x, u8 reg,
+		u8 mask)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, 0);
+}
+
+/**
+ * @brief bd7181x_update_bits
+ * update bits in one register of bd7181x
+ * @param bd7181x device to read
+ * @param reg register address
+ * @param mask mask bits
+ * @param val value to update
+ * @retval 0 if success
+ * @retval negative error number if fail
+ */
+
+static inline int bd7181x_update_bits(struct bd7181x *bd7181x, u8 reg,
+					   u8 mask, u8 val)
+{
+	return regmap_update_bits(bd7181x->regmap, reg, mask, val);
+}
+
+/**
+ * @brief bd7181x platform data type
+ */
+struct bd7181x_gpo_plat_data {
+	u32 mode;		///< gpo output mode
+	int gpio_base;		///< base gpio number in system
+};
+
+#endif /* __LINUX_MFD_BD7181X_H */
+
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 63fb12d..9051bcd 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -264,6 +264,18 @@ config SND_SOC_IMX_SII902X
 	 Say Y if you want to add support for SoC audio on an i.MX board with
 	 a sii902x.
 
+config SND_SOC_IMX_WM8731
+	tristate "SoC Audio support for i.MX boards with wm8731"
+	depends on OF && I2C
+	select SND_SOC_WM8731
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_IMX_AUDMUX
+	select SND_SOC_FSL_SSI
+	select SND_SOC_FSL_UTILS
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a wm8731 codec.
+
 config SND_SOC_IMX_WM8958
 	tristate "SoC Audio support for i.MX boards with wm8958"
 	depends on OF && I2C
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index e29f6ec..0d4ac2b 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -55,6 +55,7 @@ snd-soc-mx27vis-aic32x4-objs := mx27vis-aic32x4.o
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
 snd-soc-imx-cs42888-objs := imx-cs42888.o
 snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
+snd-soc-imx-wm8731-objs := imx-wm8731.o
 snd-soc-imx-wm8958-objs := imx-wm8958.o
 snd-soc-imx-wm8960-objs := imx-wm8960.o
 snd-soc-imx-wm8962-objs := imx-wm8962.o
@@ -71,6 +72,7 @@ obj-$(CONFIG_SND_SOC_MX27VIS_AIC32X4) += snd-soc-mx27vis-aic32x4.o
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
 obj-$(CONFIG_SND_SOC_IMX_CS42888) += snd-soc-imx-cs42888.o
 obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_WM8731) += snd-soc-imx-wm8731.o
 obj-${CONFIG_SND_SOC_IMX_WM8958} += snd-soc-imx-wm8958.o
 obj-${CONFIG_SND_SOC_IMX_WM8960} += snd-soc-imx-wm8960.o
 obj-$(CONFIG_SND_SOC_IMX_WM8962) += snd-soc-imx-wm8962.o
diff --git a/sound/soc/fsl/imx-wm8731.c b/sound/soc/fsl/imx-wm8731.c
new file mode 100644
index 0000000..0e26127
--- /dev/null
+++ b/sound/soc/fsl/imx-wm8731.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Based on imx-sgtl5000.c
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/mfd/syscon.h>
+
+#include "../codecs/wm8731.h"
+#include "imx-audmux.h"
+#include "imx-ssi.h"
+
+#define DAI_NAME_SIZE	32
+
+struct imx_wm8731_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	struct i2c_client *codec_dev;
+	struct clk *codec_clk;
+	long sysclk;
+};
+
+static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd);
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+                                       struct snd_pcm_hw_params *params);
+
+struct imx_priv {
+	struct platform_device *pdev;
+	struct imx_wm8731_data *data;
+};
+
+static struct imx_priv card_priv;
+
+static struct snd_soc_ops imx_hifi_ops = {
+	.hw_params 	= imx_hifi_hw_params_slv_mode,
+};
+
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack",       NULL),
+	SND_SOC_DAPM_SPK("Ext Spk",             NULL),
+	SND_SOC_DAPM_LINE("Line Jack",          NULL),
+	SND_SOC_DAPM_MIC("Mic Jack",            NULL),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack",     NULL,   "LHPOUT" },
+	{ "Headphone Jack",     NULL,   "RHPOUT" },
+
+	{ "Ext Spk",            NULL,   "LOUT" },
+	{ "Ext Spk",            NULL,   "ROUT" },
+
+	{ "LLINEIN",            NULL,   "Line Jack" },
+	{ "RLINEIN",            NULL,   "Line Jack" },
+
+	{ "MICIN",              NULL,   "Mic Bias" },
+	{ "Mic Bias",           NULL,   "Mic Jack"},
+};
+
+
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_card *card = codec_dai->codec->card;
+	struct imx_wm8731_data *data = snd_soc_card_get_drvdata(card);
+	
+	u32 dai_format;
+	snd_pcm_format_t sample_format;
+	unsigned int channels;
+	unsigned int tx_mask, rx_mask;
+	unsigned int sampling_rate;
+	unsigned int div_2, div_psr, div_pm;
+	int ret;
+
+	sampling_rate = params_rate(params);
+	sample_format = params_format(params);
+	
+	channels = params_channels(params);
+/*	printk("%s:%s  sampling rate = %u  channels = %u \n", __FUNCTION__,
+		   (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "Playback" : "Capture"),
+		   sampling_rate, channels);*/
+
+	/* set CPU DAI configuration */
+	switch (sampling_rate) {
+		case 8000:
+		case 32000:
+		case 48000:
+		case 96000:
+			data->sysclk = 12288000;
+			break;
+
+		case 44100:
+		case 88200:
+			data->sysclk = 11289600;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	/* S[TR]CCR:DC */
+	tx_mask = ~((1 << channels) - 1);
+	rx_mask = tx_mask;
+	snd_soc_dai_set_tdm_slot(cpu_dai, tx_mask, rx_mask, 2, 32);
+
+	/*
+	 * SSI sysclk divider:
+	 * div_2:	/1 or /2
+	 * div_psr:	/1 or /8
+	 * div_pm:	/1 .. /256
+	 */
+	div_2	= 0;
+	div_psr	= 0;
+	switch (sampling_rate) {
+		case 8000:
+			// 1x1x12
+			div_pm	= 11;
+			break;
+		case 32000:
+			// 1x1x3
+			div_pm	= 2;
+			break;
+		case 48000:
+			// 1x1x2
+			div_pm	= 1;
+			break;
+		case 96000:
+			// 1x1x1
+			div_pm	= 0;
+			break;
+		case 44100:
+			// 1x1x2
+			div_pm	= 1;
+			break;
+		case 88200:
+			// 1x1x1
+			div_pm	= 0;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* sync mode: a single clock controls both playback and capture */
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_2, (div_2 ? SSI_STCCR_DIV2 : 0));
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PSR, (div_psr ? SSI_STCCR_PSR : 0));
+	snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, div_pm);
+
+	/* set codec DAI configuration */
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai,
+				     WM8731_SYSCLK_MCLK,
+				     data->sysclk,
+				     SND_SOC_CLOCK_IN);
+
+	if (ret < 0) {
+		pr_err("Failed to set codec master clock to %lu: %d \n",
+		       data->sysclk, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_soc_codec *codec = rtd->codec;
+
+	/* Add imx specific widgets */
+	ret = snd_soc_dapm_new_controls(&codec->dapm, imx_dapm_widgets,
+									ARRAY_SIZE(imx_dapm_widgets));
+	if (ret)
+			goto out_retcode;
+
+	/* Set up imx specific audio path audio_map */
+	ret = snd_soc_dapm_add_routes(&codec->dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret)
+			goto out_retcode;
+
+	ret = snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
+	if (ret)
+			goto out_retcode;
+
+	ret = snd_soc_dapm_nc_pin(&codec->dapm, "Ext Spk");
+	if (ret)
+			goto out_retcode;
+
+out_retcode:
+
+	if (ret)
+			pr_err("%s: failed with error code: %d \n", __FUNCTION__, ret);
+	else
+			pr_info("%s: success \n", __FUNCTION__);
+
+	return ret;
+}
+
+/**
+ * Configure AUDMUX interconnection between
+ * _slave (CPU side) and _master (codec size)
+ *
+ * When SSI operates in master mode, 5-wire interconnect with
+ * audio codec is required:
+ * TXC  - BCLK
+ * TXD  - DAC data
+ * RXD  - ADC data
+ * TXFS - {DAC|ADC}LRC, i.e. word clock
+ * RXC  - MCLK, i.e. oversampling clock
+ * Audmux is operated in asynchronous mode to enable 6-wire
+ * interface (as opposed to 4-wire interface in sync mode).
+ */
+static int imx_audmux_config_slv_mode(int _slave, int _master)
+{
+	unsigned int ptcr, pdcr;
+	int slave = _slave - 1;
+	int master = _master - 1;
+
+	ptcr = IMX_AUDMUX_V2_PTCR_SYN |
+		IMX_AUDMUX_V2_PTCR_TFSDIR |
+		IMX_AUDMUX_V2_PTCR_TFSEL(slave) |
+		IMX_AUDMUX_V2_PTCR_RCLKDIR |
+		IMX_AUDMUX_V2_PTCR_RCSEL(slave | 0x8) |
+		IMX_AUDMUX_V2_PTCR_TCLKDIR |
+		IMX_AUDMUX_V2_PTCR_TCSEL(slave);
+
+	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(slave);
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+	ptcr = ptcr & ~IMX_AUDMUX_V2_PTCR_SYN;
+	imx_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	ptcr = IMX_AUDMUX_V2_PTCR_SYN |
+		IMX_AUDMUX_V2_PTCR_RCLKDIR |
+		IMX_AUDMUX_V2_PTCR_RCSEL(master | 0x8) |
+		IMX_AUDMUX_V2_PTCR_TCLKDIR |
+		IMX_AUDMUX_V2_PTCR_TCSEL(master);
+
+	pdcr = IMX_AUDMUX_V2_PDCR_RXDSEL(master);
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+	ptcr = ptcr & ~IMX_AUDMUX_V2_PTCR_SYN;
+	imx_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	return 0;
+}
+
+
+static int imx_wm8731_probe(struct platform_device *pdev)
+{
+	struct device_node *ssi_np, *codec_np;
+	struct platform_device *ssi_pdev;
+	struct imx_priv *priv = &card_priv;
+	struct i2c_client *codec_dev;
+	struct imx_wm8731_data *data;
+	unsigned int src_port, ext_port;
+
+	int ret;
+	u32 out_val[3];
+	phandle phandle;
+	struct regmap *gpr;
+	struct device_node *node;
+
+	priv->pdev = pdev;
+	
+	ssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!ssi_np || !codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ssi_pdev = of_find_device_by_node(ssi_np);
+	if (!ssi_pdev) {
+		dev_err(&pdev->dev, "failed to find SSI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+        
+	codec_dev = of_find_i2c_device_by_node(codec_np);
+	if (!codec_dev) {
+		dev_err(&pdev->dev, "failed to find codec platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	do {
+		ret = of_property_read_u32_array(pdev->dev.of_node, "gpr", out_val, 3);
+		if (ret) break;
+
+		phandle = *out_val;
+		node = of_find_node_by_phandle(phandle);
+		if (!node) break;
+
+		gpr = syscon_node_to_regmap(node);
+		if (IS_ERR(gpr)) break;
+
+		of_node_put(node);
+
+		/*
+		 * set SAI2_MCLK_DIR to enable codec MCLK
+		 * out_val[1] is the register offset
+		 * out_val[2] is the bit field
+		 */
+		regmap_update_bits(gpr, out_val[1], (1<<out_val[2]), (1<<out_val[2]));
+
+
+	} while(0);
+
+	card_priv.data = data;
+
+	data->codec_dev = codec_dev;
+
+	data->codec_clk = devm_clk_get(&codec_dev->dev, NULL);
+	if (IS_ERR(data->codec_clk)) {
+		ret = PTR_ERR(data->codec_clk);
+		dev_err(&codec_dev->dev, "failed to get codec clk: %d\n", ret);
+		goto fail;	
+	}
+
+//	data->clk_frequency = clk_get_rate(data->codec_clk);	
+	ret = clk_prepare_enable(data->codec_clk);
+
+	if (ret) {
+		dev_err(&codec_dev->dev, "failed to enable codec clk: %d\n", ret);
+		goto fail;
+	}
+
+	data->dai.name = "HiFi";
+	data->dai.stream_name = "HiFi";
+	data->dai.codec_dai_name = "wm8731-hifi";
+	data->dai.codec_of_node = codec_np;
+	data->dai.cpu_dai_name = dev_name(&ssi_pdev->dev);
+	data->dai.platform_of_node = ssi_np;
+	data->dai.ops = &imx_hifi_ops;
+	data->dai.init = &imx_wm8731_init;
+	
+	ret = of_property_read_u32(pdev->dev.of_node, "src-port", &src_port);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get \"src-port\" value\n");
+		ret = -EINVAL;
+		goto clk_fail;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node, "ext-port", &ext_port);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get \"ext-port\" value\n");
+		ret = -EINVAL;
+		goto clk_fail;
+	}
+
+	imx_audmux_config_slv_mode(src_port, ext_port);
+
+	
+	data->card.dev = &pdev->dev;
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret)
+		goto clk_fail;
+	
+	ret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");
+	if (ret)
+		goto clk_fail;
+
+
+	data->card.num_links = 1;
+	data->card.dai_link = &data->dai;
+
+	data->card.dapm_widgets = imx_dapm_widgets;
+	data->card.num_dapm_widgets = ARRAY_SIZE(imx_dapm_widgets);
+
+	platform_set_drvdata(pdev, &data->card);
+	snd_soc_card_set_drvdata(&data->card, data);
+
+	ret = snd_soc_register_card(&data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto clk_fail;
+
+	}
+	
+	return 0;
+
+clk_fail:
+	clk_disable_unprepare(data->codec_clk);
+
+fail:
+
+	if (ssi_np)
+		of_node_put(ssi_np);
+
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static int imx_wm8731_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct imx_wm8731_data *data = snd_soc_card_get_drvdata(card);
+ 
+	if (!IS_ERR(data->codec_clk))
+		clk_disable_unprepare(data->codec_clk);
+
+	snd_soc_unregister_card(card);
+
+	return 0;
+}
+
+static const struct of_device_id imx_wm8731_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-wm8731", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_wm8731_dt_ids);
+
+static struct platform_driver imx_wm8731_driver = {
+	.driver = {
+		.name = "imx-wm8731",
+		.owner = THIS_MODULE,
+		.of_match_table = imx_wm8731_dt_ids,
+	},
+	.probe = imx_wm8731_probe,
+	.remove = imx_wm8731_remove,
+};
+module_platform_driver(imx_wm8731_driver);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Freescale i.MX WM8731 ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-wm8731");
+
